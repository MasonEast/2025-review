1. axios 情况是否可以取消？

可以

- 使用 axios 的 cancelToken 来取消请求
- Fetch API 的 AbortController 取消请求

2. cookie 可以实现不同域共享吗？

通常，Cookie 不能直接在不同域间共享，这源于浏览器同源策略，该策略由协议、域名和端口号共同界定"源"，只有三者完全相同才属同源，Cookie 才能在其间共享。但在特定条件和技术手段下，可实现不同域间一定程度的 Cookie 共享，同时，Cookie 也能设置为在同主域下的子域间共享

3. cookie 和 session 的区别？

- cookie 存储在客户端，session 存储在服务器端
- cookie 的大小限制为 4k，session 的大小没有限制
- cookie 的安全性较低，容易被窃取，session 的安全性较高，存储在服务器端，不易被窃取
- cookie 的生命周期由浏览器控制，session 的生命周期由服务器控制
- cookie 可以设置在同主域下的子域间共享，Session 不能设置在同主域下的子域间共享

4. cookie 和 token 的区别？

- cookie 存储在客户端，token 存储在客户端和服务器端
- cookie 的大小限制为 4k，token 的大小没有限制
- cookie 的安全性较低，容易被窃取，token 的安全性较高，存储在客户端和服务器端，不易被窃取
- cookie 的生命周期由浏览器控制，token 的生命周期由服务器控制

5. cookie 和 localStorage 的区别？

- cookie 存储在客户端，localStorage 存储在客户端
- cookie 的大小限制为 4k，localStorage 的大小没有限制
- cookie 的安全性较低，容易被窃取，localStorage 的安全性较高，不易被窃取
- cookie 的生命周期由浏览器控制，localStorage 的生命周期由开发者控制
- cookie 可以设置在同主域下的子域间共享，localStorage 不能设置在同主域下的子域间共享

6. px 如何转换为 rem

px（像素）转换为 rem（根元素字体大小的相对单位）需要先确定一个基准的根元素字体大小。通常，我们会将根元素字体大小设置为 16px，然后根据这个基准来计算 rem 值。

例如，如果要将 50px 转换为 rem，可以按照以下步骤进行：计算 50px 相对于根元素字体大小的比例，即 50 / 16 = 3.125

追问，如何自动转换 px 为 rem？

可以使用 CSS 预处理器（如 Sass、Less）或者 JavaScript 库（如 px2rem）来实现 px 到 rem 的自动转换。这些工具可以帮助我们在编写 CSS 时自动将 px 转换为 rem，从而简化开发过程。

7. 如何减少项目里面 if-else

可以使用设计模式来减少项目中的 if-else 语句。以下是一些常见的设计模式：

- 策略模式：将不同的算法封装在不同的策略类中，通过上下文类来选择合适的策略。这样可以避免在代码中直接使用 if-else 语句来选择算法。
- 状态模式：将对象的状态封装在不同的状态类中，通过上下文类来切换状态。这样可以避免在代码中使用 if-else 语句来处理不同的状态。
- 命令模式：将请求封装为命令对象，通过命令对象来执行请求。这样可以避免在代码中使用 if-else 语句来处理不同的请求。
- 观察者模式：将对象的状态变化通知给其他对象，通过观察者模式来避免在代码中使用 if-else 语句来处理不同的状态变化。

8. 如何实现一个深拷贝

可以使用以下方法来实现一个深拷贝：

- 使用 JSON 序列化和反序列化：将对象序列化为 JSON 字符串，然后再将 JSON 字符串反序列化为新的对象。这种方法简单易行，但是无法处理函数、Symbol、循环引用等特殊情况。
- 使用递归拷贝：递归地拷贝对象的每个属性，包括嵌套的对象和数组。这种方法可以处理循环引用，但是性能较差。
- 使用第三方库：如 lodash 的 cloneDeep 方法，可以方便地实现深拷贝。

9. ajax 和 xhr 是什么关系？

AJAX（Asynchronous JavaScript and XML）是一种在网页中实现异步数据交换的技术。它允许网页在不重新加载整个页面的情况下，与服务器进行数据交换，从而实现动态更新网页内容的效果。

XHR（XMLHttpRequest）是 AJAX 技术的核心对象。它允许 JavaScript 在不重新加载页面的情况下，向服务器发送请求并接收响应。XHR 对象提供了丰富的 API，可以方便地处理请求和响应，包括设置请求头、发送请求、处理响应等。

10. 浏览器的同源策略

浏览器的同源策略是一种安全策略，用于限制不同源之间的资源交互。同源是指协议、域名和端口号都相同的两个 URL。同源策略限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。

同源策略的主要目的是防止恶意网站通过脚本窃取其他网站的数据。例如，如果用户访问了一个恶意网站，该网站可以通过脚本获取用户在另一个网站上的 cookie，从而窃取用户的身份信息。

同源策略限制了以下几种资源交互：

- 跨域请求：浏览器不允许网页向不同源的服务器发送请求。
- 跨域脚本执行：浏览器不允许网页执行来自不同源的外部脚本。
- 跨域文档访问：浏览器不允许网页访问来自不同源的其他文档的内容。

同源策略可以通过以下几种方式来绕过：

- JSONP：通过动态创建 script 标签，并设置其 src 属性为不同源的 URL，从而实现跨域请求。
- CORS：通过服务器设置 Access-Control-Allow-Origin 头部字段，允许跨域请求。
- 代理服务器：通过代理服务器将请求转发到目标服务器，从而绕过同源策略的限制。

11. 什么是 CDN

CDN（Content Delivery Network）是一种用于加速网站内容分发和访问的技术。它通过在全球多个节点上部署缓存服务器，将网站的内容（如 HTML、CSS、JavaScript、图片等）缓存起来，从而减少用户访问网站时的延迟，提高网站的访问速度和稳定性。

CDN 的工作原理如下：

1. 用户访问网站时，浏览器会向 CDN 的 DNS 服务器发送请求。
2. CDN 的 DNS 服务器根据用户的地理位置和请求的内容，返回离用户最近的缓存服务器的 IP 地址。
3. 浏览器向缓存服务器发送请求，缓存服务器会根据请求的内容，返回缓存的内容给浏览器。
4. 如果缓存服务器没有缓存该内容，它会向源服务器请求内容，并将内容缓存起来，以便下次用户访问时可以直接返回缓存的内容。

CDN 的主要优点包括：

- 提高网站访问速度：通过在全球多个节点上部署缓存服务器，CDN 可以减少用户访问网站时的延迟，提高网站的访问速度。
- 提高网站稳定性：CDN 可以通过负载均衡和故障转移等技术，提高网站的稳定性，减少网站宕机时间。
- 降低带宽成本：CDN 可以通过将内容缓存到多个节点上，减少源服务器的带宽压力，降低带宽成本。

12. babel-runtime 作用是啥

babel-runtime 是一个 Babel 插件，用于解决 Babel 编译后的代码中的一些全局变量和内置函数的问题。
在 Babel 编译 ES6+ 代码时，会使用一些全局变量和内置函数，如 Promise、Symbol 等。这些全局变量和内置函数在不同的 JavaScript 环境中可能存在差异，导致编译后的代码在不同的环境中无法正常运行。

babel-runtime 插件通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，然后在编译后的代码中引用这个模块，从而解决全局变量和内置函数的问题。

babel-runtime 插件的主要作用包括：

- 解决全局变量和内置函数的问题：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，然后在编译后的代码中引用这个模块，从而解决全局变量和内置函数的问题。
- 提高代码的可维护性：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，可以减少代码的重复，提高代码的可维护性。
- 提高代码的可移植性：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，可以减少代码对特定环境的依赖，提高代码的可移植性。

13. 前端假如有几十个请求，如何控制并发？

在前端开发中，如果需要发送多个请求，可以使用 Promise.all() 方法来控制并发请求的数量。

Promise.all() 方法接受一个包含多个 Promise 对象的数组作为参数，并返回一个新的 Promise 对象。当数组中的所有 Promise 对象都变为 resolved 状态时，新的 Promise 对象才会变为 resolved 状态，并返回一个包含所有 resolved 状态的 Promise 对象的数组。

如果数组中的某个 Promise 对象变为 rejected 状态，新的 Promise 对象会立即变为 rejected 状态，并返回第一个 rejected 状态的 Promise 对象的原因。

通过使用 Promise.all() 方法，可以控制并发请求的数量，避免同时发送过多的请求导致服务器压力过大。例如，如果需要发送 10 个请求，可以创建一个包含 10 个 Promise 对象的数组，然后使用 Promise.all() 方法来并发发送这 10 个请求。

14. 如何去衡量用户操作中是否卡顿？

- 使用浏览器性能指标 - FPS（每秒帧数）
- 监测 Long Tasks（长任务）（PerformanceObserver API）
- 分析 First Input Delay（首次输入延迟 - FID）

15. 为何主流图表库都用 canvas 而不是 svg？

- 性能方面：Canvas 在处理大量数据时性能更好，因为它使用的是位图，而 SVG 使用的是矢量图。位图在处理大量数据时可以更快地渲染，而矢量图在处理大量数据时可能会出现性能问题。
- 内存占用：Canvas 在处理大量数据时占用的内存更少，因为它使用的是位图，而 SVG 使用的是矢量图。位图在处理大量数据时占用的内存更少，而矢量图在处理大量数据时可能会占用更多的内存。
- 灵活性：Canvas 在处理大量数据时具有更高的灵活性，因为它可以使用 JavaScript 来动态地绘制图形，而 SVG 在处理大量数据时可能会出现性能问题。

SVG 也有其自身的优势，如可编辑性强、支持矢量缩放、对搜索引擎友好等

16. 如何将深层次子组件的方法抛给顶层组件调用？

- 使用 props 逐层传递
- 使用 useContext API
- 使用事件总线(dispatchEvent): 创建一个全局的事件总线，在子组件中触发事件，在顶层组件中监听事件

17. canvas 是如何处理复杂事件交互的？

由于 canvas 只是一个像素绘制区域，本身并不像常规 HTML 元素那样具有内置的事件处理机制。所以需要通过以下方式来处理事件交互：

- 监听整个文档或包含 canvas 的容器元素的事件。
- 根据事件发生的坐标位置判断是否在 canvas 内部以及与特定图形的交互。

- 使用事件委托：将事件监听器添加到 canvas 元素上，然后根据事件的坐标来判断事件是否发生在某个图形上。
- 使用 hitTest 函数：在 canvas 上绘制图形时，可以使用 hitTest 函数来判断某个点是否在某个图形上。
- 使用事件冒泡：将事件监听器添加到 canvas 元素上，然后使用事件冒泡机制来处理事件。当事件发生时，事件会从子元素冒泡到父元素，然后可以在父元素中处理事件。

18. 如何统计前端请求耗时？

- Fetch，XMLHttpRequest，Axios 等请求库都提供了相应的方法来获取请求的耗时。
- 使用 Performance API 来获取页面加载的各个阶段的耗时。
- 使用 web worker

19. 排查谁在修改对象？

例如：redux 申请了一份数据 store , 整个应用有特别多的地方在修改这个 store , 现在数据出现异常， 如何排查是哪儿场景修改的这份 store 导致的异常;

- 使用 redux-devtools 插件，可以查看 redux store 的变化历史，找到是哪个 action 导致了 store 的变化。
- 冻结对象，或使用 proxy 劫持对象，限制调用对象的方法。

20. 进程和线程？

- 进程：进程是操作系统分配资源的基本单位，每个进程都有自己的内存空间和系统资源。进程间通信需要操作系统介入，开销较大。
- 线程：线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。线程共享进程的内存空间和资源，线程间通信开销较小。

21. 解释 SQL 中的事务及其四个特性（ACID）

- 事务：事务是一组操作，要么全部成功，要么全部失败，不会出现部分成功、部分失败的情况。
- ACID：
  - 原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成，不会停留在中间某个状态。
  - 一致性（Consistency）：事务执行前后，数据库的状态必须保持一致。
  - 隔离性（Isolation）：并发事务之间相互隔离，不会互相影响。
  - 持久性（Durability）：事务一旦提交，其所做的修改就会永久保存到数据库中。

22. 设计一个高并发的 web 服务器

- 负载均衡：使用负载均衡器（如 Nginx）将请求分发到多个服务器，提高系统的可用性和扩展性。
- 缓存：使用缓存（如 Redis、Memcached）减少数据库访问，提高响应速度。
- 数据库分库分表：将数据库进行水平切分，提高数据库的读写能力。
- 消息队列：使用消息队列（如 Kafka、RabbitMQ）处理高并发请求，削峰填谷。
- 服务化：将系统拆分成多个微服务，每个服务独立部署，提高系统的可维护性和扩展性。

23. 数组哪些方法可以改变自身

- push()：在数组末尾添加一个或多个元素，并返回新数组的长度。
- pop()：删除数组末尾的一个元素，并返回该元素。
- shift()：删除数组开头的一个元素，并返回该元素。
- unshift()：在数组开头添加一个或多个元素，并返回新数组的长度。
- splice()：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。
- sort()：对数组元素进行排序，并返回排序后的数组。
- reverse()：颠倒数组中元素的顺序，并返回颠倒后的数组。

不改变自身的方法

- slice()：返回一个新的数组对象，这个对象是一个由原数组中的指定开始至结束（不包括结束）之间的项组成的浅拷贝。
- concat()：用于合并两个或多个数组。此方法不会改变现有的数组，而是返回一个新数组。
- map()：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
- filter()：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
- forEach()：对数组的每个元素执行一次提供的函数。
- reduce()：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。
- every()：测试一个数组内的所有元素是否都能通过一个指定函数的测试。它返回一个布尔值。
- some()：测试数组中是不是至少有一个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。
- find()：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
- findIndex()：返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
- includes()：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。

24. 前端工程如何避免循环依赖

有一些静态分析工具可以帮助检测循环依赖。例如，ESLint 的插件`eslint-plugin-import`可以配置规则来检测模块之间的循环依赖

25. 闭包使用场景

- 数据隐藏和封装：闭包可以用来创建私有变量，这些变量只能在闭包内部访问，从而实现数据的隐藏和封装。
- 模块化：闭包可以用来创建模块，每个模块都有自己的私有变量和函数，通过闭包可以暴露出模块的公共接口。
- 延迟执行：闭包可以用来实现延迟执行，例如在事件处理函数中，可以使用闭包来保存事件处理函数的上下文，从而在事件触发时执行相应的操作。
- 回调函数：闭包可以用来创建回调函数，这些回调函数可以在异步操作完成后执行相应的操作。
- 函数柯里化：闭包可以用来实现函数柯里化，即将一个多参数的函数转换成一系列单参数函数。
- 缓存计算结果

26. 如何使用 node 开发一个全局命令行工具

这个问题， 其实本质就是一个 package.json 配置里面的 bin 配置，然后通过 npm link 命令链接到全局，就可以使用命令行工具了。

- 创建一个 package.json 文件，`npm init`, 指定 name 字段为命令行工具的名称，type 字段为"module"，main 字段为入口文件。
- 安装 commander 模块，这是一个用于构建命令行界面的流行工具
- 开发代码
- 在项目的 package.json 文件中，添加一个 bin 字段，指定命令行工具的入口文件，并`npm link`

27. 什么是 semver 规范，~1.2.3 和^1.2.3 的版本范围

semver 规范是一种版本号规范，用于描述软件的版本。它由三部分组成：主版本号、次版本号和修订号，用点号分隔。例如，1.2.3 表示主版本号为 1，次版本号为 2，修订号为 3。

~1.2.3 表示允许更新修订号，但不允许更新主版本号和此版本号。即匹配大于等于 1.2.3 且小于 1.3.0 的版本
^1.2.3 表示兼容版本，即允许更新次版本号和修订号，但不允许更新主版本号。即匹配大于等于 1.2.3 且小于 2.0.0 的版本

28. npm install 之后需要执行一些处理工作，该怎么做

- 在 package.json 文件中，添加一个 scripts 字段，指定需要执行的命令，例如"postinstall": "node build.js"
- 第三方工具，husky 和 lint-staged（用于代码检查和格式化等场景

29. 事件循环应用场景

- 异步 I/O 操作：例如网络请求、文件读写等操作，可以在操作完成后执行相应的回调函数。
- 事件监听：例如点击事件、键盘事件等，可以在事件触发时执行相应的回调函数。
- 微任务：Promise 和 async/await 可以用来创建微任务，这些任务会在当前任务执行完成后立即执行。
- 宏任务：setTimeout、setInterval、I/O 操作等可以用来创建宏任务，这些任务会在当前任务执行完成后，等待下一个事件循环再执行。

30. 前端 CI/CD

- Jenkins
- GitLab CI/CD
- GitHub Actions
- Travis CI

31. 如何保证项目质量

- 需求分析与规划：
  - 和业务方充分了解需求，确保了解项目背景，项目目标，功能需求等，并形成需求文档；
  - 制定项目计划，明确项目进度，里程碑，资源需求等，并形成项目计划文档；
  - 制定项目规范，明确代码规范，文档规范，测试规范等，并形成项目规范文档；
- 编码与测试：
  - 编写代码时，遵循项目规范，使用合适的编程语言和框架，编写可读性高，可维护性好的代码；
  - 编写单元测试，确保代码的正确性和稳定性；
  - 编写集成测试，确保代码与系统其他部分的兼容性；
  - 编写端到端测试，确保代码与用户需求的匹配度；
- 代码审查：
  - 代码审查是保证项目质量的重要手段，通过代码审查，可以及时发现代码中的问题，提高代码质量；
  - 代码审查应该由经验丰富的工程师进行，审查的内容包括代码风格，代码逻辑，代码性能等；
  - 代码审查应该定期进行，可以在代码提交时进行，也可以在代码合并时进行；
- 持续集成与持续部署：
  - 持续集成与持续部署是保证项目质量的重要手段，通过持续集成与持续部署，可以及时发现代码中的问题，提高代码质量；
  - 持续集成与持续部署应该自动化进行，可以通过 Jenkins，GitLab CI/CD，GitHub Actions 等工具实现；
  - 持续集成与持续部署应该定期进行，可以在代码提交时进行，也可以在代码合并时进行；
- 项目监控与优化：
  - 项目监控是保证项目质量的重要手段，通过项目监控，可以及时发现项目中的问题，提高项目质量；
  - 项目监控应该定期进行，可以通过日志，监控工具等方式实现；

32. vue nextTick 作用及原理

- 确保 DOM 更新后执行操作
- 处理异步操作后的 DOM 操作：比如，在一个 Ajax 请求成功后，你想要根据返回的数据更新 DOM，这时可以在请求成功的回调函数中使用 nextTick 来确保 DOM 更新已经完成。

原理：

- 利用事件循环： Vue 将 nextTick 的回调函数放入微任务队列（在 Promise.then、MutationObserver 和 process.nextTick 中执行）或宏任务队列（在 setTimeout、setInterval 和 setImmediate 中执行），具体取决于浏览器的支持情况。

- Vue 内部维护了一个异步任务队列，用于存储 nextTick 的回调函数。当调用 nextTick 时，回调函数会被添加到这个队列中。

33. 现代框架如 React、Vue 相比原生开发有什么优势

- 提高开发效率：

  - 组件化开发；
  - 虚拟 DOM

- 更好的用户体验：

  - 数据绑定；
  - 路由管理；
  - 状态管理；

- 更好的可维护性：

  - 代码复用；
  - 代码结构清晰；

- 跨平台开发：
  - React Native；
  - Vue Native；
  - 服务端渲染

34. vue3 对虚拟 dom 做了哪些优化

- 使用 Proxy 代替 Object.defineProperty： Proxy 可以监听对象和数组的变化，而 Object.defineProperty 只能监听对象的属性变化；
- 使用 Fragments： Fragments 可以让组件返回多个根节点，而不用再创建一个额外的节点；
- 使用 Static Fragments： Static Fragments 可以让 Vue 知道哪些节点是静态的，不需要每次渲染都重新创建；
- 使用 Block： Block 可以让 Vue 知道哪些节点是动态的，需要每次渲染都重新创建；
- 使用 Composition API： Composition API 可以让开发者更灵活地组织代码，提高代码的可维护性；

35. 如何计算页面白屏时间

- 使用`performance` API：统计浏览器开始导航页面（`performance.timing.navigationStart`），到 DOMContentLoaded 事件触发的时间差；
- 使用自定义标记：插入一个空 div，开始为`display:none`在页面加载完成后，DOMContentLoaded 中设置为`display: block`，计算这个 div 的加载时间；

36. [webpack] 是如何处理 commonjs 模块的文件， 使其编译结果能被浏览器使用

- 模块解析
  - webpack 会根据配置的入口文件，递归地解析模块依赖，生成一个依赖图；
- 模块转换
  - 处理 require 函数；
  - 处理 module.exports 函数；
  - 代码优化和转换： Tree Shaking， 代码压缩，模块合并
  - webpack 会将模块转换成浏览器可以识别的代码，例如将 CommonJS 转换成 ES6 模块；
- 代码打包
  - webpack 会将转换后的代码打包成一个或多个文件，这些文件可以在浏览器中运行；

37. 前端如何处理一个页面多主题色可供选择的场景

- 使用 css 变量：定义一组变量，然后在需要的地方使用这些变量，通过修改变量的值来改变主题色；

  - 使用 CSS 预处理器：使用 Sass、Less 等预处理器，可以定义变量，然后在需要的地方使用这些变量；
  - 使用 CSS-in-JS：使用 CSS-in-JS 库，例如 styled-components，可以在 JavaScript 中定义样式，然后通过组件的 props 来改变样式；
  - 切换主题：通过切换 CSS 文件来改变主题色，例如使用 link 标签引入不同的 CSS 文件，然后通过 JavaScript 来切换 link 标签的 href 属性；

- 定义 CSS 样式类
  - 定义一组样式类，然后在需要的地方使用这些样式类，通过修改变量的值来改变主题色；

38. iterator 对象有哪些特征
    iterator 对象是为了实现对可迭代对象（如数组、字符串、集合等）的遍历操作而设计的。它提供了一种标准化的方式来依次访问可迭代对象中的元素

- 迭代器对象具有一个 next() 方法，该方法返回一个对象，该对象包含两个属性：value 和 done。value 属性表示下一个要迭代的元素，done 属性表示迭代是否已经完成。
- 与可迭代对象关联：迭代器对象与可迭代对象关联，可以通过调用可迭代对象的 Symbol.iterator 方法来获取迭代器对象。
- Iterator 对象通常只能进行单向遍历，即从可迭代对象的起始位置依次访问到结束位置，不能反向遍历。一旦迭代完成，再次调用 next()方法将始终返回{ value: undefined, done: true }
- terator 对象可以与 for...of 循环、扩展运算符（...）、解构赋值等语言特性一起使用

39. 在 Node.js 中，process.nextTick()和 setTimeout()的区别

- 执行时机

  - nextTick 会在当前事件循环的当前阶段结束后立即执行回调函数。这意味着它会在所有同步代码执行完毕后，但在事件循环进入下一个阶段之前执行
  - setTimeout 会在指定的延迟时间过后，将回调函数添加到事件循环的定时器阶段进行执行。实际的执行时间可能会比指定的延迟时间稍长，因为它取决于事件循环的负载和其他正在等待执行的任务。

- 用途
  - nextTick 通常用于在当前事件循环的当前阶段立即执行一些异步操作，例如清理操作、更新状态等。它适用于需要在当前阶段立即执行一些操作的场景。

40. [React] 对象数据状态不可变是什么概念

- 保证数据的稳定性和可预测性
  - 避免意外的副作用: 当数据不可变时，任何对数据的修改都会返回一个新的对象，而不是修改原始对象。
  - 易于理解和调试: 当数据不可变时，可以更容易地追踪数据的变更历史，因为每次修改都会返回一个新的对象。
- 提高性能
  - 减少不必要的渲染: 当数据不可变时，React 可以通过比较新旧数据来决定是否需要重新渲染组件。如果新旧数据相同，React 就不会重新渲染组件，从而提高性能。
  - 简化状态管理: 当数据不可变时，可以更容易地管理状态。例如，可以使用函数式编程技术，如纯函数和不可变数据结构，来简化状态管理。
- 实现
  - 使用不可变数据结构: 可以使用不可变数据结构，如 Immutable.js 或 immer.js，来创建不可变的数据。
  - 使用函数式编程技术: 可以使用函数式编程技术，如纯函数和不可变数据结构，来简化状态管理。

41. [React] 在 setState 时发生了什么

42. https 层可以做哪些性能优化

- 服务器优化
  - 使用 CDN: CDN 可以将静态资源（如图片、CSS、JavaScript 文件等）缓存在全球各地的边缘服务器上，从而减少数据传输的距离，提高加载速度。
  - 使用 HTTP/2: HTTP/2 是一种新的 HTTP 协议，它支持多路复用、服务器推送等功能，可以显著提高页面加载速度。
  - 使用 HTTP/3: HTTP/3 是基于 QUIC 协议的 HTTP 版本，它支持低延迟和高可靠性，可以进一步提高页面加载速度。
- 证书优化
  - 使用 ECC 证书: ECC 证书比 RSA 证书更安全，而且具有更短的密钥长度，可以减少加密和解密的时间，提高页面加载速度。
  - 使用 OCSP Stapling: OCSP Stapling 可以减少证书验证的时间，提高页面加载速度。
  - 证书缓存和预取
- TLS 会话复用
- 客户端优化
  - 使用缓存: 浏览器缓存可以减少重复请求，提高页面加载速度。
  - 使用压缩: 压缩可以减少数据传输的大小，提高页面加载速度。
  - 使用懒加载: 懒加载可以将页面中的非关键资源（如图片、视频等）延迟加载，从而减少初始加载时间。

43. [React]在应用中如何排查性能问题

- 使用 Chrome 开发者工具
  - 打开 Chrome 开发者工具，选择 "Performance" 标签。
  - 点击 "Record" 按钮开始录制性能数据。
  - 在应用中进行一些操作，例如滚动页面、点击按钮等。
  - 点击 "Stop" 按钮停止录制性能数据。
  - 在 "Performance" 标签中查看性能数据，找到性能瓶颈。
- 使用 React Developer Tools
  - 安装 React Developer Tools 扩展。
  - 打开 Chrome 开发者工具，选择 "Components" 标签。
- 使用 React Profiler
  - 安装 React Profiler。
  - 在应用中调用 `ReactDOM.unstable_createRoot` 创建根节点。
  - 在根节点上调用 `root.render` 渲染组件。
  - 在组件中调用 `Profiler` 组件，并传入一个回调函数，该回调函数会在每次渲染后调用，并传入一个 `id` 和 `phase` 参数。
  - 在回调函数中，可以使用 `console.log` 打印性能数据，例如渲染时间、更新时间等。
- 检查代码中的潜在问题
  - 检查代码中的性能瓶颈，例如不必要的渲染、过大的组件等。
  - 检查代码中的内存泄漏，例如未正确释放的引用等。
  - 检查代码中的异步操作，例如网络请求、定时器等，确保它们不会阻塞主线程。

44. [React]React 18 中 Concurrent Mode 的作用是什么

- Concurrent Mode 是 React 18 中引入的一种新的模式，它允许 React 应用程序在多个任务之间进行切换，从而提高应用的响应性和性能。
- 在 Concurrent Mode 中，React 会将渲染任务分成多个小任务，并在主线程空闲时执行这些任务。这样，即使渲染任务需要很长时间，用户界面也不会被阻塞，从而提高了应用的响应性。
- Concurrent Mode 还提供了一些新的 API，例如 `startTransition` 和 `useDeferredValue`，这些 API 可以帮助开发者更好地控制渲染任务的优先级和执行时机，从而进一步提高应用的性能。

45. [React]React 18 中 useTransition 的作用是什么

- `useTransition` 是 React 18 中引入的一个新的 Hook，它允许开发者将渲染任务标记为过渡任务，从而提高应用的响应性和性能。
- 过渡任务是指那些可能需要较长时间才能完成的渲染任务，例如网络请求、数据加载等。在默认情况下，React 会将这些任务视为高优先级的任务，并在主线程空闲时立即执行它们。然而，这可能会导致用户界面被阻塞，从而降低应用的响应性。

46. 有哪些前端性能分析工具

- Chrome DevTools：Chrome DevTools 是一个强大的前端性能分析工具，它提供了多种性能分析工具，例如 Performance、Memory、Lighthouse 等。这些工具可以帮助开发者分析应用的性能瓶颈，优化应用的性能。
- Lighthouse：Lighthouse 是一个开源的自动化工具，它可以帮助开发者分析网页的性能、可访问性、SEO 等方面。Lighthouse 提供了一个报告，其中包含了详细的性能分析数据，以及一些优化建议。
- WebPageTest：WebPageTest 是一个在线的性能测试工具，它可以帮助开发者分析网页的性能。WebPageTest 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- GTmetrix：GTmetrix 是一个在线的性能测试工具，它可以帮助开发者分析网页的性能。GTmetrix 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- Pingdom：Pingdom 是一个在线的性能测试工具，它可以帮助开发者分析网页的性能。Pingdom 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- YSlow：YSlow 是一个开源的浏览器插件，它可以帮助开发者分析网页的性能。YSlow 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- SpeedCurve：SpeedCurve 是一个在线的性能测试工具，它可以帮助开发者分析网页的性能。SpeedCurve 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- Google PageSpeed Insights：Google PageSpeed Insights 是一个在线的性能测试工具，它可以帮助开发者分析网页的性能。Google PageSpeed Insights 提供了一个详细的报告，其中包含了性能分析数据、网络请求、渲染时间等。
- Web Vitals：Web Vitals 是一组关键的性能指标，它可以帮助开发者分析网页的性能。Web Vitals 包括了 Largest Contentful Paint（LCP）、First Input Delay（FID）和 Cumulative Layout Shift（CLS）等指标。

47. [React]React 18 中 useDeferredValue 的作用是什么

- `useDeferredValue` 是 React 18 中引入的一个新的 Hook，它允许开发者将渲染任务标记为延迟任务，从而提高应用的响应性和性能。
- `useDeferredValue` 接受一个值作为参数，并返回一个新的值。当这个值发生变化时，React 会将渲染任务标记为延迟任务，而不是立即执行。这意味着，当这个值发生变化时，React 不会立即更新组件，而是将更新任务推迟到下一个渲染周期。
- `useDeferredValue` 的主要作用是提高应用的响应性和性能。当应用中有大量的数据需要处理时，React 可能会花费大量的时间来更新组件。使用 `useDeferredValue` 可以将这些更新任务推迟到下一个渲染周期，从而提高应用的响应性。

48. http3 有哪些核心的新特性

HTTP/3 是 HTTP 协议的最新版本，它引入了一些新的核心特性，包括：

- QUIC 协议：HTTP/3 使用了 QUIC（Quick UDP Internet Connections）协议，这是一种基于 UDP 的传输协议。QUIC 协议提供了一些新的特性，如低延迟、多路复用、快速重连等，这些特性可以提高 HTTP/3 的性能和可靠性。
- 多路复用：HTTP/3 支持多路复用，这意味着多个请求可以在一个连接上同时进行，而不需要等待前一个请求完成。这可以大大提高 HTTP/3 的性能和效率。
- 快速重连：QUIC 协议提供了一些新的特性，如快速重连，这意味着在连接中断后，可以快速地重新建立连接，而不需要重新进行三次握手等复杂的操作。这可以大大提高 HTTP/3 的可靠性和稳定性。
- 流量控制：HTTP/3 提供了一些新的流量控制机制，这些机制可以更好地控制数据的传输速率，从而提高 HTTP/3 的性能和稳定性。
- 压缩头部：HTTP/3 提供了一些新的压缩头部机制，这些机制可以大大减少 HTTP 请求和响应的头部大小，从而提高 HTTP/3 的性能和效率。
- 更好的安全性：HTTP/3 提供了一些新的安全性机制，如 TLS 1.3，这些机制可以更好地保护 HTTP/3 的数据传输安全。

这些新的核心特性使得 HTTP/3 在性能、可靠性和安全性方面都有很大的改进，可以更好地满足现代互联网应用的需求。

49. 前端部署应该要考虑哪些问题

- 高可用性与故障应对:生产环境中，单点故障是必须考虑的问题。若一台物理机突然崩溃，应用需依然能够正常运行。这时可以了解 Kubernetes（k8s）的 Deployment，它能够有效地应对单点故障，确保应用的高可用性。
- 负载均衡:当应用部署在多台物理机时，如何将请求合理地分配到各个服务器上，是负载均衡需要解决的问题。k8s 的 Service 可以实现负载均衡，将请求分发到各个 Pod 上。
- 自动扩缩容:当应用负载过高时，需要增加服务器来处理请求；当负载降低时，需要减少服务器以节省资源。k8s 的 Horizontal Pod Autoscaler（HPA）可以根据 CPU 使用率或其他指标，自动调整 Pod 的数量。
- 日志与监控:生产环境中，需要实时监控应用的运行状态，以便及时发现并解决问题。k8s 提供了丰富的日志和监控工具，如 Prometheus、Grafana 等，可以实时监控应用的运行状态。
- 热更新与用户体验：当需要更新应用时，要做到让用户无感知。同样，k8s 的 Deployment 提供了热更新的功能，能够在不影响用户使用的情况下完成应用的更新
- 版本回退机制：当应用更新后出现问题时，需要能够快速回退到之前的版本。k8s 的 Deployment 提供了版本回退机制，可以在出现问题时快速回退到之前的版本。

50. 前端需要加载一个大体积的文件时， 一般有哪些优化思路

- 分片加载：将大文件分成多个小文件，按需加载，避免一次性加载整个文件。
- 压缩文件：对大文件进行压缩，减少文件大小，提高加载速度。
- 懒加载：将大文件放在页面底部，只有当用户滚动到页面底部时，才开始加载文件。
- 缓存：将大文件缓存到本地，当用户再次访问时，可以直接从本地缓存中加载文件，提高加载速度。
- 使用 CDN：将大文件部署到 CDN 上，用户可以从离自己最近的服务器加载文件，提高加载速度。

51. 分片上传文件，如何校验文件完整性

- 使用哈希值算法
  - 计算文件哈希值
  - 上传文件携带哈希值
  - 服务器端计算文件哈希值并与上传的哈希值进行比对，如果一致则文件完整，否则文件损坏
- 文件大小比较
- 上传状态跟踪

52. http 缓存 header 中的 Date 与 Last-Modified 有什么不同

- 含义不同
  - Date: 表示响应报文在服务器生成的时间
  - Last-Modified: 表示资源在服务器上的最后修改时间
- 作用不同
  - Date: 用于记录服务器生成响应报文的时间，客户端可以通过比较客户端本地时间与服务器时间，判断响应报文是否过时
  - Last-Modified: 用于记录资源在服务器上的最后修改时间，客户端可以通过比较资源的最后修改时间与服务器时间，判断资源是否过时

53. [Vue] 对比一下 vuex 和 Pinia 两个状态库

- 相似之处
  - 集中式状态管理
  - 响应式状态
- 不同
  - pinia 的语法和 api 更简洁

54. axios 如何取消请求

- 使用 axios.signal， axios.cancelToken 已弃用

55. 在 forEach 中和 for 循环 中调用异步函数的区别

- forEach 中调用异步函数，会立即执行所有异步函数，而不会等待异步函数执行完毕
- for 循环中调用异步函数，会等待异步函数执行完毕后，再执行下一个异步函数

56. mobx 和 redux 有什么区别

- 设计理念不同
  - redux: 集中式状态管理，通过 action 和 reducer 来管理状态，其设计理念是保持状态的可预测性，鼓励使用纯函数来执行状态变更
  - mobx: 响应式状态管理，在 MobX 中，你可以直接修改状态，而 MobX 会负责跟踪这些状态的变化，并自动应用任何副作用（如重新渲染 UI）。这种方式使得状态管理更加直观和灵活，但可能会牺牲一些可预测性。
- 性能
  - redux: 对于大型应用，由于每次状态更新都会执行可能涉及整个状态树的深度比较，因此可能需要仔细优化选择器和避免不必要的渲染。
  - mobx: 由于其使用响应式系统仅跟踪实际使用的状态部分，并在这部分状态变更时才更新，通常能提供更好的运行时性能，尤其是在大型应用中。
- 适用场景
  - redux: 适用于大型应用，需要保持状态的可预测性，并且有良好的可维护性
  - mobx: 适用于中小型应用，需要快速开发，并且对性能要求不是特别高

57. tree-shaking 是什么，原理是什么

Webpack 的 Tree Shaking 主要是用来消除未被使用的代码，以减小最终打包文件的体积

- 原理：Webpack 通过静态分析代码，识别出未被使用的代码，并在打包过程中将其移除。具体来说，Webpack 会分析模块的导出和导入，以及模块的引用情况，从而确定哪些代码是真正被使用的。然后，Webpack 会将这些被使用的代码打包到最终的输出文件中，而未被使用的代码则会被移除。

- 实现条件：Tree Shaking 只能对 ES6 模块进行优化，因为 ES6 模块具有静态结构，可以在编译时确定模块的导出和导入。对于 CommonJS 模块，由于它们在运行时确定模块的导出和导入，因此无法进行 Tree Shaking 优化。

58. vite 开发和构建有何不同

- vite 开发模式：使用 esbuild 预构建依赖，使用原生 ES 模块导入，无需打包，直接启动开发服务器，支持热更新
- vite 构建模式：使用 Rollup 打包，支持 tree-shaking，支持压缩代码，支持多页面应用

59. 前端应用有哪些代码测试手段

- 单元测试（Jest，Mocha，Jasmine）：对单个函数或模块进行测试，确保其功能正确；
- 集成测试（Cypress，Puppeteer）：对多个模块或组件进行测试，确保它们之间的交互正确；
- 端到端测试（Cypress，Puppeteer）：对整个应用进行测试，确保用户交互流程正确；
- 性能测试（Lighthouse，WebPageTest）：对应用的性能进行测试，确保其运行速度快，用户体验好；
- 回归测试：对已发布的版本进行测试，确保新版本的功能正确，并且没有引入新的 bug。

60. pnpm install 和 npm install 有什么区别

61. 如何做静态资源预加载

- webworker：在 web worker 中加载静态资源，避免阻塞主线程；
- 通过 Service Workers 缓存静态资源，以便在后续访问时更快加载
- 使用预加载指令（如 `<link rel="preload">`）提前加载静态资源；

62. [webpack] 如何优化产物大小

- 代码分割：将代码分割成多个小的 chunk，按需加载，减少初始加载时间；
- Tree Shaking：移除未使用的代码，减小最终打包文件的体积；
- 压缩代码：使用 UglifyJS、Terser 等工具压缩代码，减小文件体积；
- 利用缓存(Caching): 使用 [contenthash] 替换 [hash] 或 [chunkhash] 来为输出文件命名，这确保了只有当文件内容改变时，文件名称才会改变，可以更好地利用浏览器缓存
- 使用 PurgeCSS 或 purify-css 等工具检查你的 CSS 文件，自动去除未使用的 CSS，可以极大地压缩 CSS 的体积。
- 使用 image-webpack-loader 等图片压缩插件，可以减小图片文件的体积。
- 使用动态 Polyfills: 只为那些实际需要它们的浏览器提供 polyfills，而不是所有浏览器都提供。

63. 什么是预检请求

预检请求是 method 为 OPTIONS 的请求

- 作用
  - 检查服务器是否允许跨域请求
  - 检查服务器是否支持请求中的方法（如 GET、POST 等）
  - 检查服务器是否支持请求中的头信息（如 Content-Type、Authorization 等）
  - 检查服务器是否需要身份验证（如 Basic Auth、Bearer Token 等）
- 请求头
  - Origin：请求的来源，即发起请求的网页的 URL
  - Access-Control-Request-Method：请求的方法，如 GET、POST 等
  - Access-Control-Request-Headers：请求的头信息，如 Content-Type、Authorization 等
- 响应头
  - Access-Control-Allow-Origin：服务器允许的请求来源，如 \* 表示允许所有来源
  - Access-Control-Allow-Methods：服务器允许的方法，如 GET、POST 等
  - Access-Control-Allow-Headers：服务器允许的头信息，如 Content-Type、Authorization 等

64. 请求数量过多，该如何治理

- 使用缓存：将常用和公用的请求结果缓存起来，避免重复请求；
- 使用批量请求：将多个请求合并为一个请求，减少请求次数；
- 使用长连接：使用 HTTP/2 或 WebSocket 等协议，保持连接长时间有效，减少连接建立和断开的开销；
- 使用 CDN：将静态资源部署到 CDN 上，减少请求的延迟；
- 使用负载均衡：将请求分发到多个服务器上，提高系统的并发处理能力；
- 使用服务端渲染：将页面渲染逻辑放在服务器端，减少客户端的请求次数；
- 使用 WebAssembly：将计算密集型任务编译成 WebAssembly，提高计算性能。

65. 前端性能优化

- 代码层面
  - 代码压缩：使用工具如 Terser、UglifyJS 等压缩 JavaScript 代码，减小文件体积；
  - 代码分割：将代码分割成多个小的模块，按需加载，减少首次加载时间；
  - 懒加载：将不立即需要的资源延迟加载，减少首次加载时间；
  - Tree Shaking：去除无用代码，减小文件体积；
  - 代码缓存：使用 HTTP 缓存策略，减少重复请求；
  - 使用 Web Workers：将计算密集型任务放在 Web Workers 中执行，避免阻塞主线程；
  - 使用 Service Workers：缓存资源，提高离线体验；
  - 使用 HTTP/2：使用多路复用、头部压缩等技术，提高请求速度；

66. 如何确定用户的网络条件，包括网络速度和连接状态

- Navigator Connection API：使用 Navigator Connection API 可以获取到用户的网络连接状态，包括网络类型、网络速度等；
- HTML5 引入了在线和离线事件监听，可以用来简单判断用户是否连接到网络。
- 通过发送一个小请求（可能是一个小文件或 API 请求）并测量它完成的时间，可以粗略地估计当前的网络速度。

67. 在页面关闭时执行方法，该如何做

- 可以使用 window 对象的 beforeunload 和 unload 事件
- 使用 navigator.sendBeacon：要用于追踪和诊断信息，特别是在需要确保数据被成功发送到服务器的场景中——比如记录用户在网页上的行为数据。
- fetch keepalive： keepalive 选项在 fetch 请求中的作用主要是允许在浏览器即将关闭或者用户即将离开当前页面时，仍然能够成功发送网络请求

```js
window.addEventListener("unload", (event) => {
  navigator.sendBeacon("/log-out", "用户离开");
});
```

68. new function 和 new class 的异同

- new function 和 new class 都是 JavaScript 中创建对象的方式，但它们有一些重要的区别。

- new function

  - 使用 new 关键字调用一个函数时，JavaScript 会创建一个新的对象，并将该对象作为函数的上下文（this）。
  - 函数的返回值会被忽略，除非函数显式地返回一个对象。
  - new function 可以用于创建一个简单的对象，但它的语法相对复杂，容易出错。

- new class
  - 使用 new 关键字调用一个类时，JavaScript 会创建一个新的对象，并将该对象作为类的实例。
  - 类的构造函数（constructor）会被调用，用于初始化对象的属性。
  - 类的方法可以通过 this 关键字访问类的属性和其他方法。
  - 类的语法相对简单，易于理解和使用，但需要使用 ES6 或更高版本的 JavaScript。

69. [vue] scope 是怎么做的样式隔离的

- Vue 的 scoped 样式是通过 CSS 的属性选择器实现的。
- 在编译过程中，Vue 会为每个组件的样式添加一个唯一的属性选择器，例如 [data-v-123456]。
- 在渲染组件时，Vue 会将这个属性选择器添加到组件的根元素上，从而将样式限制在当前组件内。
- 当其他组件的样式与当前组件的样式发生冲突时，由于属性选择器的唯一性，Vue 会确保样式不会应用到其他组件上。

70. [vue] 如何实现一个自定义指令

- Vue 的自定义指令是通过 Vue.directive 函数来定义的。
- 自定义指令可以用于在 DOM 元素上添加一些特殊的行为，例如自动聚焦、拖拽等。
- 自定义指令可以接受一个或多个参数，例如 DOM 元素、指令的值、指令的修饰符等。
- 自定义指令可以定义一个钩子函数，用于在指令的不同生命周期阶段执行一些操作，例如 bind、inserted、update、componentUpdated、unbind 等。

71. [vue] 如何实现一个自定义插件

- Vue 的自定义插件是通过 Vue.use 函数来使用的。
- 自定义插件可以用于在 Vue 实例上添加一些全局的功能，例如全局组件、全局指令、全局过滤器等。
- 自定义插件可以接受一个或多个参数，例如 Vue 实例、插件选项等。
- 自定义插件可以定义一个 install 方法，用于在插件被使用时执行一些操作，例如注册全局组件、全局指令、全局过滤器等。

72. [vue] 如何实现一个自定义组件

- Vue 的自定义组件是通过 Vue.component 函数来定义的。
- 自定义组件可以用于在 Vue 实例上添加一些可复用的 UI 组件，例如按钮、表单、对话框等。
- 自定义组件可以接受一个或多个参数，例如组件的名称、组件的选项等。
- 自定义组件可以定义一个模板、一个样式、一个脚本等，用于描述组件的外观和行为。
- 自定义组件可以定义一个生命周期钩子函数，用于在组件的不同生命周期阶段执行一些操作，例如 created、mounted、updated、destroyed 等。

73. [vue] 如何实现一个自定义过滤器

- Vue 的自定义过滤器是通过 Vue.filter 函数来定义的。
- 自定义过滤器可以用于在 Vue 模板中添加一些特殊的功能，例如格式化日期、转换大小写等。
- 自定义过滤器可以接受一个或多个参数，例如过滤器的名称、过滤器的选项等。
- 自定义过滤器可以定义一个函数，用于在过滤器被调用时执行一些操作，例如格式化日期、转换大小写等。

74. JS 数据类型里面， Set 和 数组分别有哪些适用场景，开发中该如何抉择？

- Set 是一种集合数据类型，用于存储一组唯一的值。它没有重复的元素，并且可以快速地添加、删除和查找元素。Set 可以用于存储一组唯一的值，例如用户的选择、标签等。
- 数组是一种有序的集合数据类型，用于存储一组有序的值。它有重复的元素，并且可以快速地添加、删除和查找元素。数组可以用于存储一组有序的值。

75. [vue] Vue 生命周期钩子函数有哪些，分别有什么作用？

- Vue 的生命周期钩子函数是 Vue 实例在不同生命周期阶段执行的一些操作，例如创建、挂载、更新、销毁等。
- Vue 的生命周期钩子函数包括 created、mounted、updated、destroyed 等。

76. [React] 类组件中，为什么修改状态要使用 setState 而不是用 this.state.xxx = xxx

- 保证状态的不可变性（Immutability）：React 强烈建议开发人员保持状态（state）的不可变性。这意味着状态不应被直接修改，而应该通过创建一个新的状态对象来更新
- 组件重新渲染：setState 方法不仅更新状态，而且还告诉 React 该组件及其子组件需要重新渲染，以反映状态的变化。直接修改 this.state 不会触发组件的重新渲染
- 合并状态更新

77. [webpack] 构建过程中， 是如何将我们 es6 代码 编译为 es5

- Babel 转换：Babel 是一个流行的 JavaScript 编译器，可以将 ES6+ 代码转换为向后兼容的 JavaScript 版本，即 ES5。Webpack 可以与 Babel 配合使用，通过 Babel Loader 来实现代码的转换。
- loader 配置：在 Webpack 配置中，你可以指定使用 Babel Loader 来处理 .js 文件。当 Webpack 处理 JavaScript 文件时，Babel Loader 会被调用，并将 ES6 代码转换为 ES5。
- Babel 预设： Babel 使用预设（presets）来定义转换规则。@babel/preset-env 是一个常用的预设，它会自动配置 Babel 以兼容目标浏览器的版本。
- Polyfills： 为了支持旧浏览器，Babel 还可以引入 polyfills，这些是提供现代 JavaScript 特性的第三方代码片段。例如，core-js 和 regenerator-runtime 是两个常用的 polyfill 库。
- 转换过程：
  1. 解析
  2. 转换
  3. 生成

78. [webpack] webpack 的热更新原理是什么

- Webpack 的热更新（Hot Module Replacement，简称 HMR）是一种在应用程序运行时替换、添加或删除模块，而无需重新加载整个页面的技术。HMR 可以显著提高开发效率，因为它允许开发人员实时看到代码更改的效果，而不必每次都手动刷新页面。
- Webpack HMR 的原理基于 WebSocket 和模块热替换（Hot Module Replacement）机制。具体来说，HMR 的实现过程如下：

  1. Webpack 在构建过程中会生成一个额外的 Websocket 服务器，用于与客户端进行通信。
  2. 当文件发生变化时，Webpack 会通过 Websocket 服务器将更新通知发送给客户端。
  3. 客户端收到更新通知后，会通过 Websocket 服务器请求更新的模块代码。
  4. 客户端接收到更新的模块代码后，会将其应用到当前运行的模块中，从而实现热更新。
