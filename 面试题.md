1. axios 情况是否可以取消？

可以

- 使用 axios 的 cancelToken 来取消请求
- Fetch API 的 AbortController 取消请求

2. cookie 可以实现不同域共享吗？

通常，Cookie 不能直接在不同域间共享，这源于浏览器同源策略，该策略由协议、域名和端口号共同界定“源”，只有三者完全相同才属同源，Cookie 才能在其间共享。但在特定条件和技术手段下，可实现不同域间一定程度的 Cookie 共享，同时，Cookie 也能设置为在同主域下的子域间共享

3. cookie 和 session 的区别？

- cookie 存储在客户端，session 存储在服务器端
- cookie 的大小限制为 4k，session 的大小没有限制
- cookie 的安全性较低，容易被窃取，session 的安全性较高，存储在服务器端，不易被窃取
- cookie 的生命周期由浏览器控制，session 的生命周期由服务器控制
- cookie 可以设置在同主域下的子域间共享，session 不能设置在同主域下的子域间共享

4. cookie 和 token 的区别？

- cookie 存储在客户端，token 存储在客户端和服务器端
- cookie 的大小限制为 4k，token 的大小没有限制
- cookie 的安全性较低，容易被窃取，token 的安全性较高，存储在客户端和服务器端，不易被窃取
- cookie 的生命周期由浏览器控制，token 的生命周期由服务器控制

5. cookie 和 localStorage 的区别？

- cookie 存储在客户端，localStorage 存储在客户端
- cookie 的大小限制为 4k，localStorage 的大小没有限制
- cookie 的安全性较低，容易被窃取，localStorage 的安全性较高，不易被窃取
- cookie 的生命周期由浏览器控制，localStorage 的生命周期由开发者控制
- cookie 可以设置在同主域下的子域间共享，localStorage 不能设置在同主域下的子域间共享

6. px 如何转换为 rem

px（像素）转换为 rem（根元素字体大小的相对单位）需要先确定一个基准的根元素字体大小。通常，我们会将根元素字体大小设置为 16px，然后根据这个基准来计算 rem 值。

例如，如果要将 50px 转换为 rem，可以按照以下步骤进行：计算 50px 相对于根元素字体大小的比例，即 50 / 16 = 3.125

追问，如何自动转换 px 为 rem？

可以使用 CSS 预处理器（如 Sass、Less）或者 JavaScript 库（如 px2rem）来实现 px 到 rem 的自动转换。这些工具可以帮助我们在编写 CSS 时自动将 px 转换为 rem，从而简化开发过程。

7. 如何减少项目里面 if-else

可以使用设计模式来减少项目中的 if-else 语句。以下是一些常见的设计模式：

- 策略模式：将不同的算法封装在不同的策略类中，通过上下文类来选择合适的策略。这样可以避免在代码中直接使用 if-else 语句来选择算法。
- 状态模式：将对象的状态封装在不同的状态类中，通过上下文类来切换状态。这样可以避免在代码中使用 if-else 语句来处理不同的状态。
- 命令模式：将请求封装为命令对象，通过命令对象来执行请求。这样可以避免在代码中使用 if-else 语句来处理不同的请求。
- 观察者模式：将对象的状态变化通知给其他对象，通过观察者模式来避免在代码中使用 if-else 语句来处理不同的状态变化。

8. 如何实现一个深拷贝

可以使用以下方法来实现一个深拷贝：

- 使用 JSON 序列化和反序列化：将对象序列化为 JSON 字符串，然后再将 JSON 字符串反序列化为新的对象。这种方法简单易行，但是无法处理函数、Symbol、循环引用等特殊情况。
- 使用递归拷贝：递归地拷贝对象的每个属性，包括嵌套的对象和数组。这种方法可以处理循环引用，但是性能较差。
- 使用第三方库：如 lodash 的 cloneDeep 方法，可以方便地实现深拷贝。

9. ajax 和 xhr 是什么关系？

AJAX（Asynchronous JavaScript and XML）是一种在网页中实现异步数据交换的技术。它允许网页在不重新加载整个页面的情况下，与服务器进行数据交换，从而实现动态更新网页内容的效果。

XHR（XMLHttpRequest）是 AJAX 技术的核心对象。它允许 JavaScript 在不重新加载页面的情况下，向服务器发送请求并接收响应。XHR 对象提供了丰富的 API，可以方便地处理请求和响应，包括设置请求头、发送请求、处理响应等。

10. 浏览器的同源策略

浏览器的同源策略是一种安全策略，用于限制不同源之间的资源交互。同源是指协议、域名和端口号都相同的两个 URL。同源策略限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。

同源策略的主要目的是防止恶意网站通过脚本窃取其他网站的数据。例如，如果用户访问了一个恶意网站，该网站可以通过脚本获取用户在另一个网站上的 cookie，从而窃取用户的身份信息。

同源策略限制了以下几种资源交互：

- 跨域请求：浏览器不允许网页向不同源的服务器发送请求。
- 跨域脚本执行：浏览器不允许网页执行来自不同源的外部脚本。
- 跨域文档访问：浏览器不允许网页访问来自不同源的其他文档的内容。

同源策略可以通过以下几种方式来绕过：

- JSONP：通过动态创建 script 标签，并设置其 src 属性为不同源的 URL，从而实现跨域请求。
- CORS：通过服务器设置 Access-Control-Allow-Origin 头部字段，允许跨域请求。
- 代理服务器：通过代理服务器将请求转发到目标服务器，从而绕过同源策略的限制。

11. 什么是 CDN

CDN（Content Delivery Network）是一种用于加速网站内容分发和访问的技术。它通过在全球多个节点上部署缓存服务器，将网站的内容（如 HTML、CSS、JavaScript、图片等）缓存起来，从而减少用户访问网站时的延迟，提高网站的访问速度和稳定性。

CDN 的工作原理如下：

1. 用户访问网站时，浏览器会向 CDN 的 DNS 服务器发送请求。
2. CDN 的 DNS 服务器根据用户的地理位置和请求的内容，返回离用户最近的缓存服务器的 IP 地址。
3. 浏览器向缓存服务器发送请求，缓存服务器会根据请求的内容，返回缓存的内容给浏览器。
4. 如果缓存服务器没有缓存该内容，它会向源服务器请求内容，并将内容缓存起来，以便下次用户访问时可以直接返回缓存的内容。

CDN 的主要优点包括：

- 提高网站访问速度：通过在全球多个节点上部署缓存服务器，CDN 可以减少用户访问网站时的延迟，提高网站的访问速度。
- 提高网站稳定性：CDN 可以通过负载均衡和故障转移等技术，提高网站的稳定性，减少网站宕机时间。
- 降低带宽成本：CDN 可以通过将内容缓存到多个节点上，减少源服务器的带宽压力，降低带宽成本。

12. babel-runtime 作用是啥

babel-runtime 是一个 Babel 插件，用于解决 Babel 编译后的代码中的一些全局变量和内置函数的问题。
在 Babel 编译 ES6+ 代码时，会使用一些全局变量和内置函数，如 Promise、Symbol 等。这些全局变量和内置函数在不同的 JavaScript 环境中可能存在差异，导致编译后的代码在不同的环境中无法正常运行。

babel-runtime 插件通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，然后在编译后的代码中引用这个模块，从而解决全局变量和内置函数的问题。

babel-runtime 插件的主要作用包括：

- 解决全局变量和内置函数的问题：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，然后在编译后的代码中引用这个模块，从而解决全局变量和内置函数的问题。
- 提高代码的可维护性：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，可以减少代码的重复，提高代码的可维护性。
- 提高代码的可移植性：通过将全局变量和内置函数的实现代码提取出来，并将其打包成一个模块，可以减少代码对特定环境的依赖，提高代码的可移植性。

13. 前端假如有几十个请求，如何控制并发？

在前端开发中，如果需要发送多个请求，可以使用 Promise.all() 方法来控制并发请求的数量。

Promise.all() 方法接受一个包含多个 Promise 对象的数组作为参数，并返回一个新的 Promise 对象。当数组中的所有 Promise 对象都变为 resolved 状态时，新的 Promise 对象才会变为 resolved 状态，并返回一个包含所有 resolved 状态的 Promise 对象的数组。

如果数组中的某个 Promise 对象变为 rejected 状态，新的 Promise 对象会立即变为 rejected 状态，并返回第一个 rejected 状态的 Promise 对象的原因。

通过使用 Promise.all() 方法，可以控制并发请求的数量，避免同时发送过多的请求导致服务器压力过大。例如，如果需要发送 10 个请求，可以创建一个包含 10 个 Promise 对象的数组，然后使用 Promise.all() 方法来并发发送这 10 个请求。

14. 如何去衡量用户操作中是否卡顿？

- 使用浏览器性能指标 - FPS（每秒帧数）
- 监测 Long Tasks（长任务）（PerformanceObserver API）
- 分析 First Input Delay（首次输入延迟 - FID）

15. 为何主流图表库都用 canvas 而不是 svg？

- 性能方面：Canvas 在处理大量数据时性能更好，因为它使用的是位图，而 SVG 使用的是矢量图。位图在处理大量数据时可以更快地渲染，而矢量图在处理大量数据时可能会出现性能问题。
- 内存占用：Canvas 在处理大量数据时占用的内存更少，因为它使用的是位图，而 SVG 使用的是矢量图。位图在处理大量数据时占用的内存更少，而矢量图在处理大量数据时可能会占用更多的内存。
- 灵活性：Canvas 在处理大量数据时具有更高的灵活性，因为它可以使用 JavaScript 来动态地绘制图形，而 SVG 在处理大量数据时可能会出现性能问题。

SVG 也有其自身的优势，如可编辑性强、支持矢量缩放、对搜索引擎友好等

16. 如何将深层次子组件的方法抛给顶层组件调用？

- 使用 props 逐层传递
- 使用 useContext API
- 使用事件总线(dispatchEvent): 创建一个全局的事件总线，在子组件中触发事件，在顶层组件中监听事件

17. canvas 是如何处理复杂事件交互的？

由于 canvas 只是一个像素绘制区域，本身并不像常规 HTML 元素那样具有内置的事件处理机制。所以需要通过以下方式来处理事件交互：

- 监听整个文档或包含 canvas 的容器元素的事件。
- 根据事件发生的坐标位置判断是否在 canvas 内部以及与特定图形的交互。

- 使用事件委托：将事件监听器添加到 canvas 元素上，然后根据事件的坐标来判断事件是否发生在某个图形上。
- 使用 hitTest 函数：在 canvas 上绘制图形时，可以使用 hitTest 函数来判断某个点是否在某个图形上。
- 使用事件冒泡：将事件监听器添加到 canvas 元素上，然后使用事件冒泡机制来处理事件。当事件发生时，事件会从子元素冒泡到父元素，然后可以在父元素中处理事件。

18. 如何统计前端请求耗时？

- Fetch，XMLHttpRequest，Axios 等请求库都提供了相应的方法来获取请求的耗时。
- 使用 Performance API 来获取页面加载的各个阶段的耗时。
- 使用 web worker

19. 排查谁在修改对象？

例如：redux 申请了一份数据 store , 整个应用有特别多的地方在修改这个 store , 现在数据出现异常， 如何排查是哪儿场景修改的这份 store 导致的异常;

- 使用 redux-devtools 插件，可以查看 redux store 的变化历史，找到是哪个 action 导致了 store 的变化。
- 冻结对象，或使用 proxy 劫持对象，限制调用对象的方法。

20. 进程和线程？

- 进程：进程是操作系统分配资源的基本单位，每个进程都有自己的内存空间和系统资源。进程间通信需要操作系统介入，开销较大。
- 线程：线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。线程共享进程的内存空间和资源，线程间通信开销较小。

21. 解释 SQL 中的事务及其四个特性（ACID）

- 事务：事务是一组操作，要么全部成功，要么全部失败，不会出现部分成功、部分失败的情况。
- ACID：
  - 原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成，不会停留在中间某个状态。
  - 一致性（Consistency）：事务执行前后，数据库的状态必须保持一致。
  - 隔离性（Isolation）：并发事务之间相互隔离，不会互相影响。
  - 持久性（Durability）：事务一旦提交，其所做的修改就会永久保存到数据库中。

22. 设计一个高并发的 web 服务器

- 负载均衡：使用负载均衡器（如 Nginx）将请求分发到多个服务器，提高系统的可用性和扩展性。
- 缓存：使用缓存（如 Redis、Memcached）减少数据库访问，提高响应速度。
- 数据库分库分表：将数据库进行水平切分，提高数据库的读写能力。
- 消息队列：使用消息队列（如 Kafka、RabbitMQ）处理高并发请求，削峰填谷。
- 服务化：将系统拆分成多个微服务，每个服务独立部署，提高系统的可维护性和扩展性。

23. 数组哪些方法可以改变自身

- push()：在数组末尾添加一个或多个元素，并返回新数组的长度。
- pop()：删除数组末尾的一个元素，并返回该元素。
- shift()：删除数组开头的一个元素，并返回该元素。
- unshift()：在数组开头添加一个或多个元素，并返回新数组的长度。
- splice()：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。
- sort()：对数组元素进行排序，并返回排序后的数组。
- reverse()：颠倒数组中元素的顺序，并返回颠倒后的数组。

不改变自身的方法

- slice()：返回一个新的数组对象，这个对象是一个由原数组中的指定开始至结束（不包括结束）之间的项组成的浅拷贝。
- concat()：用于合并两个或多个数组。此方法不会改变现有的数组，而是返回一个新数组。
- map()：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
- filter()：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
- forEach()：对数组的每个元素执行一次提供的函数。
- reduce()：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。
- every()：测试一个数组内的所有元素是否都能通过一个指定函数的测试。它返回一个布尔值。
- some()：测试数组中是不是至少有一个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。
- find()：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
- findIndex()：返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
- includes()：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。

24. 前端工程如何避免循环依赖

有一些静态分析工具可以帮助检测循环依赖。例如，ESLint 的插件`eslint-plugin-import`可以配置规则来检测模块之间的循环依赖

25. 闭包使用场景

- 数据隐藏和封装：闭包可以用来创建私有变量，这些变量只能在闭包内部访问，从而实现数据的隐藏和封装。
- 模块化：闭包可以用来创建模块，每个模块都有自己的私有变量和函数，通过闭包可以暴露出模块的公共接口。
- 延迟执行：闭包可以用来实现延迟执行，例如在事件处理函数中，可以使用闭包来保存事件处理函数的上下文，从而在事件触发时执行相应的操作。
- 回调函数：闭包可以用来创建回调函数，这些回调函数可以在异步操作完成后执行相应的操作。
- 函数柯里化：闭包可以用来实现函数柯里化，即将一个多参数的函数转换成一系列单参数函数。

26. vite 开发和构建有何不同
