# 前端工程化面试题（Webpack & Vite）

## Webpack 基础

### 1. 什么是 Webpack

Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。它将项目中的各种资源（JS、CSS、图片等）作为模块处理，通过依赖关系构建依赖图，最终打包成一个或多个 bundle。

**核心概念：**
- Entry（入口）
- Output（输出）
- Loader（加载器）
- Plugin（插件）
- Mode（模式）
- Module（模块）

**优势：**
- 模块化：支持各种模块规范（ES Module、CommonJS、AMD）
- 代码分割：按需加载，优化性能
- 资源管理：统一处理各种资源
- 开发体验：热更新、Source Map
- 生态丰富：大量的 loader 和 plugin

### 2. Webpack 核心概念

**Entry（入口）：**
指定 Webpack 开始构建的起点。

```javascript
// 单入口
module.exports = {
  entry: './src/index.js'
};

// 多入口
module.exports = {
  entry: {
    app: './src/app.js',
    admin: './src/admin.js'
  }
};
```

**Output（输出）：**
告诉 Webpack 如何输出打包后的文件。

```javascript
const path = require('path');

module.exports = {
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    clean: true // 清理输出目录
  }
};
```

**Loader（加载器）：**
用于转换非 JavaScript 文件。

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.(png|jpg|gif)$/,
        type: 'asset/resource'
      }
    ]
  }
};
```

**Plugin（插件）：**
用于扩展 Webpack 的功能。

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    }),
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css'
    })
  ]
};
```

**Mode（模式）：**
指定构建环境。

```javascript
module.exports = {
  mode: 'development', // 'production' | 'development' | 'none'
};
```

- `development`：开发模式，启用 NamedChunksPlugin 和 NamedModulesPlugin
- `production`：生产模式，启用压缩、Tree Shaking 等优化
- `none`：不使用任何默认优化

## Webpack 配置详解

### 1. 基础配置

```javascript
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // 入口
  entry: './src/index.js',
  
  // 输出
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash:8].js',
    clean: true
  },
  
  // 模式
  mode: 'development',
  
  // 开发服务器
  devServer: {
    port: 3000,
    hot: true,
    open: true,
    compress: true,
    historyApiFallback: true
  },
  
  // Source Map
  devtool: 'source-map',
  
  // 模块解析
  resolve: {
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  
  // 插件
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html'
    })
  ]
};
```

### 2. Loader 配置

**处理样式：**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader', 'postcss-loader']
      },
      {
        test: /\.less$/,
        use: ['style-loader', 'css-loader', 'less-loader']
      },
      {
        test: /\.scss$/,
        use: ['style-loader', 'css-loader', 'sass-loader']
      }
    ]
  }
};
```

**处理 JavaScript：**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                useBuiltIns: 'usage',
                corejs: 3
              }]
            ]
          }
        }
      }
    ]
  }
};
```

**处理图片和字体：**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif|svg)$/,
        type: 'asset',
        parser: {
          dataUrlCondition: {
            maxSize: 10 * 1024 // 10kb
          }
        },
        generator: {
          filename: 'images/[name].[hash:8][ext]'
        }
      },
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        type: 'asset/resource',
        generator: {
          filename: 'fonts/[name].[hash:8][ext]'
        }
      }
    ]
  }
};
```

### 3. 常用插件

**HtmlWebpackPlugin：**
生成 HTML 文件。

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html',
      inject: 'body',
      minify: {
        collapseWhitespace: true,
        removeComments: true
      }
    })
  ]
};
```

**MiniCssExtractPlugin：**
提取 CSS 到单独文件。

```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name].[contenthash:8].css'
    })
  ]
};
```

**CleanWebpackPlugin：**
清理输出目录。

```javascript
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  plugins: [
    new CleanWebpackPlugin()
  ]
};
```

**CopyWebpackPlugin：**
复制文件。

```javascript
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  plugins: [
    new CopyWebpackPlugin({
      patterns: [
        { from: 'public', to: 'public' }
      ]
    })
  ]
};
```

**DefinePlugin：**
定义全局常量。

```javascript
const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production'),
      'API_URL': JSON.stringify('https://api.example.com')
    })
  ]
};
```

## Webpack 优化

### 1. 构建速度优化

**1. 缩小文件搜索范围：**
```javascript
module.exports = {
  resolve: {
    // 指定扩展名
    extensions: ['.js', '.jsx', '.json'],
    // 别名
    alias: {
      '@': path.resolve(__dirname, 'src')
    },
    // 限制搜索目录
    modules: [path.resolve(__dirname, 'node_modules')]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'),
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
};
```

**2. 使用缓存：**
```javascript
module.exports = {
  cache: {
    type: 'filesystem',
    cacheDirectory: path.resolve(__dirname, '.cache')
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            cacheDirectory: true
          }
        }
      }
    ]
  }
};
```

**3. 多进程构建：**
```javascript
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        parallel: true // 多进程压缩
      })
    ]
  }
};
```

**4. 使用 DLL：**
```javascript
// webpack.dll.config.js
const webpack = require('webpack');
const path = require('path');

module.exports = {
  entry: {
    vendor: ['react', 'react-dom', 'lodash']
  },
  output: {
    path: path.resolve(__dirname, 'dll'),
    filename: '[name].dll.js',
    library: '[name]_library'
  },
  plugins: [
    new webpack.DllPlugin({
      name: '[name]_library',
      path: path.resolve(__dirname, 'dll/[name].manifest.json')
    })
  ]
};

// webpack.config.js
const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: require('./dll/vendor.manifest.json')
    })
  ]
};
```

**5. externals：**
```javascript
module.exports = {
  externals: {
    'react': 'React',
    'react-dom': 'ReactDOM',
    'lodash': '_'
  }
};
```

### 2. 打包体积优化

**1. Tree Shaking：**
```javascript
module.exports = {
  mode: 'production', // 自动启用 Tree Shaking
  optimization: {
    usedExports: true,
    sideEffects: false
  }
};

// package.json
{
  "sideEffects": false, // 或指定有副作用的文件
  "sideEffects": ["*.css", "*.scss"]
}
```

**2. 代码分割：**
```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 第三方库
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // 公共模块
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    },
    // 运行时代码单独打包
    runtimeChunk: {
      name: 'runtime'
    }
  }
};
```

**3. 按需加载：**
```javascript
// 动态导入
const Component = () => import('./Component');

// React.lazy
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// Vue
const AsyncComponent = () => import('./AsyncComponent.vue');
```

**4. 压缩代码：**
```javascript
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true // 移除 console
          }
        }
      }),
      new CssMinimizerPlugin()
    ]
  }
};
```

**5. 图片压缩：**
```javascript
const ImageMinimizerPlugin = require('image-minimizer-webpack-plugin');

module.exports = {
  plugins: [
    new ImageMinimizerPlugin({
      minimizer: {
        implementation: ImageMinimizerPlugin.imageminGenerate,
        options: {
          plugins: [
            ['gifsicle', { interlaced: true }],
            ['jpegtran', { progressive: true }],
            ['optipng', { optimizationLevel: 5 }]
          ]
        }
      }
    })
  ]
};
```

**6. Gzip 压缩：**
```javascript
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [
    new CompressionPlugin({
      algorithm: 'gzip',
      test: /\.(js|css|html)$/,
      threshold: 10240, // 10kb
      minRatio: 0.8
    })
  ]
};
```

### 3. 运行时优化

**1. 长期缓存：**
```javascript
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js'
  },
  optimization: {
    moduleIds: 'deterministic',
    runtimeChunk: 'single',
    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```

**2. 预加载和预获取：**
```javascript
// 预加载（立即加载）
import(/* webpackPreload: true */ './Component');

// 预获取（空闲时加载）
import(/* webpackPrefetch: true */ './Component');
```

**3. CDN 加速：**
```javascript
module.exports = {
  output: {
    publicPath: 'https://cdn.example.com/'
  }
};
```

## Vite 基础

### 1. 什么是 Vite

Vite 是一个新型前端构建工具，由 Vue.js 作者尤雨溪开发。它利用浏览器原生 ES Module 特性，在开发环境下实现极快的冷启动和热更新。

**核心特点：**
- 极速的开发服务器启动
- 即时的模块热更新（HMR）
- 真正的按需编译
- 基于 Rollup 的生产构建
- 开箱即用的 TypeScript 支持

**优势：**
- 快速冷启动（无需打包）
- 即时热更新
- 真正的按需编译
- 优化的构建
- 丰富的插件生态

### 2. Vite 工作原理

**开发环境：**
```
浏览器请求
  ↓
Vite Dev Server
  ↓
ESM（原生模块）
  ↓
即时编译
  ↓
返回给浏览器
```

**生产环境：**
```
源代码
  ↓
Rollup 打包
  ↓
代码分割
  ↓
压缩优化
  ↓
输出文件
```

**关键特性：**
- 开发环境使用 esbuild 预构建依赖
- 利用浏览器原生 ESM
- 按需编译，只编译当前页面
- 生产环境使用 Rollup 打包

### 3. Vite 配置

**基础配置：**
```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  // 根目录
  root: process.cwd(),
  
  // 基础路径
  base: '/',
  
  // 开发服务器
  server: {
    port: 3000,
    open: true,
    cors: true,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  
  // 构建选项
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,
    minify: 'terser',
    chunkSizeWarningLimit: 500,
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'element-plus': ['element-plus']
        }
      }
    }
  },
  
  // 路径别名
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@components': path.resolve(__dirname, 'src/components')
    }
  },
  
  // 插件
  plugins: [
    vue(),
    react()
  ],
  
  // CSS 配置
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`
      }
    }
  }
});
```

### 4. Vite 插件

**常用插件：**

**1. Vue 插件：**
```javascript
import vue from '@vitejs/plugin-vue';
import vueJsx from '@vitejs/plugin-vue-jsx';

export default defineConfig({
  plugins: [
    vue(),
    vueJsx()
  ]
});
```

**2. React 插件：**
```javascript
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [
    react()
  ]
});
```

**3. 自动导入：**
```javascript
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers';

export default defineConfig({
  plugins: [
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      resolvers: [ElementPlusResolver()]
    }),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ]
});
```

**4. SVG 支持：**
```javascript
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons';

export default defineConfig({
  plugins: [
    createSvgIconsPlugin({
      iconDirs: [path.resolve(process.cwd(), 'src/icons')],
      symbolId: 'icon-[dir]-[name]'
    })
  ]
});
```

**5. 环境变量：**
```javascript
import dotenv from 'dotenv';

export default defineConfig(({ mode }) => {
  const env = dotenv.config({ path: `.env.${mode}` }).parsed;
  
  return {
    define: {
      'process.env': env
    }
  };
});
```

### 5. Vite 优化

**1. 依赖预构建：**
```javascript
export default defineConfig({
  optimizeDeps: {
    include: ['lodash-es', 'axios'],
    exclude: ['your-package-name']
  }
});
```

**2. 代码分割：**
```javascript
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router'],
          'ui-vendor': ['element-plus'],
          'utils': ['lodash-es', 'axios']
        }
      }
    }
  }
});
```

**3. 资源处理：**
```javascript
export default defineConfig({
  build: {
    assetsInlineLimit: 4096, // 4kb
    rollupOptions: {
      output: {
        assetFileNames: (assetInfo) => {
          const info = assetInfo.name.split('.');
          let extType = info[info.length - 1];
          if (/png|jpe?g|svg|gif|tiff|bmp|ico/i.test(extType)) {
            extType = 'images';
          } else if (/woff|woff2/.test(extType)) {
            extType = 'fonts';
          }
          return `${extType}/[name]-[hash][extname]`;
        }
      }
    }
  }
});
```

## Webpack vs Vite

### 1. 核心差异

| 特性           | Webpack        | Vite           |
| -------------- | -------------- | -------------- |
| 开发服务器启动 | 慢（需要打包） | 快（无需打包） |
| 热更新速度     | 较慢           | 极快           |
| 构建工具       | Webpack        | Rollup         |
| 配置复杂度     | 复杂           | 简单           |
| 生态成熟度     | 非常成熟       | 快速发展       |
| 浏览器支持     | 所有浏览器     | 现代浏览器     |
| 学习曲线       | 陡峭           | 平缓           |

### 2. 开发体验对比

**Webpack 开发流程：**
```
启动 → 打包所有模块 → 启动服务器 → 访问页面
修改代码 → 重新打包 → 热更新
```

**Vite 开发流程：**
```
启动 → 启动服务器（无需打包） → 访问页面
修改代码 → 即时编译 → 热更新（毫秒级）
```

### 3. 适用场景

**选择 Webpack：**
- 需要支持旧版浏览器
- 项目已经使用 Webpack
- 需要复杂的构建配置
- 大型项目，需要精细控制

**选择 Vite：**
- 新项目
- 开发体验优先
- 现代浏览器环境
- Vue 3 或 React 项目

### 4. 迁移建议

**从 Webpack 迁移到 Vite：**

1. 安装 Vite
2. 创建 vite.config.js
3. 修改入口文件
4. 调整路径别名
5. 迁移环境变量
6. 测试和优化

```bash
# 1. 安装 Vite
npm install vite @vitejs/plugin-vue -D

# 2. 修改 package.json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}

# 3. 创建 vite.config.js
# 4. 修改 index.html（移到根目录）
# 5. 更新环境变量（VITE_ 前缀）
```

## 常见面试题

### 1. Webpack 的构建流程是什么？

**构建流程：**
1. **初始化参数**：读取配置文件和命令行参数
2. **开始编译**：初始化 Compiler 对象
3. **确定入口**：根据 entry 找到入口文件
4. **编译模块**：从入口文件开始，递归处理所有依赖
5. **完成模块编译**：得到每个模块的最终内容和依赖关系
6. **输出资源**：根据依赖关系组装成 chunk
7. **输出完成**：根据配置输出到文件系统

**详细流程：**
```
初始化 
  ↓
读取配置
  ↓
创建 Compiler
  ↓
注册插件
  ↓
开始编译（run）
  ↓
确定入口（entry）
  ↓
编译模块（make）
  ├─ 加载 loader
  ├─ 解析 AST
  └─ 递归依赖
  ↓
完成编译（seal）
  ├─ 创建 chunk
  ├─ 优化 chunk
  └─ 生成代码
  ↓
输出文件（emit）
```

### 2. Loader 和 Plugin 的区别？

**Loader：**
- 文件转换器
- 处理非 JavaScript 文件
- 在模块加载时执行
- 链式调用，从右到左

**Plugin：**
- 功能扩展
- 监听 Webpack 生命周期事件
- 在整个编译过程中执行
- 使用 Compiler 和 Compilation 对象

**示例：**
```javascript
// Loader
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'] // 从右到左执行
      }
    ]
  }
};

// Plugin
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('编译完成！');
    });
  }
}

module.exports = {
  plugins: [new MyPlugin()]
};
```

### 3. 如何优化 Webpack 构建速度？

**方法：**
1. 使用高版本的 Webpack 和 Node.js
2. 缩小文件搜索范围（include、exclude）
3. 使用缓存（cache、babel-loader cacheDirectory）
4. 多进程构建（thread-loader、terser-webpack-plugin parallel）
5. 使用 DLL 或 externals
6. 使用 HardSourceWebpackPlugin
7. 合理使用 sourceMap

### 4. 如何优化 Webpack 打包体积？

**方法：**
1. Tree Shaking（移除未使用的代码）
2. 代码分割（splitChunks）
3. 按需加载（动态 import）
4. 压缩代码（TerserPlugin、CssMinimizerPlugin）
5. 图片压缩（image-minimizer-webpack-plugin）
6. Gzip 压缩（compression-webpack-plugin）
7. 提取公共代码
8. 使用 externals 排除大型库
9. Scope Hoisting（ModuleConcatenationPlugin）

### 5. 什么是 Tree Shaking？如何实现？

**Tree Shaking：**
移除 JavaScript 上下文中未引用的代码（死代码）。

**实现条件：**
1. 使用 ES6 模块语法（import/export）
2. 在 package.json 中配置 sideEffects
3. 使用 production 模式

**配置：**
```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: true
  }
};

// package.json
{
  "sideEffects": false,
  // 或指定有副作用的文件
  "sideEffects": ["*.css", "*.scss"]
}
```

### 6. Webpack 的热更新（HMR）原理是什么？

**工作原理：**
1. Webpack Compiler 编译代码
2. Bundle Server 提供文件服务
3. HMR Server 推送更新消息给浏览器
4. HMR Runtime 在浏览器端接收更新
5. 只更新修改的模块

**流程：**
```
修改代码
  ↓
Webpack 监听文件变化
  ↓
重新编译修改的模块
  ↓
通过 WebSocket 发送更新通知
  ↓
浏览器接收更新
  ↓
HMR Runtime 更新模块
  ↓
页面局部刷新
```

### 7. Vite 为什么比 Webpack 快？

**原因：**

1. **开发环境：**
   - Webpack：需要打包所有模块才能启动
   - Vite：直接启动服务器，按需编译

2. **模块处理：**
   - Webpack：使用 JavaScript 转换
   - Vite：使用 esbuild（Go 语言，快 10-100 倍）

3. **热更新：**
   - Webpack：重新编译整个模块
   - Vite：精确的模块替换

4. **浏览器支持：**
   - Webpack：需要转换所有模块
   - Vite：利用浏览器原生 ESM

### 8. Vite 的预构建是什么？

**预构建（Pre-bundling）：**
Vite 在首次启动时，会使用 esbuild 预构建依赖。

**目的：**
1. 转换 CommonJS/UMD 模块为 ESM
2. 减少模块请求数量
3. 提高页面加载性能

**配置：**
```javascript
export default defineConfig({
  optimizeDeps: {
    include: ['lodash-es', 'axios'],
    exclude: ['your-package-name'],
    esbuildOptions: {
      // esbuild 选项
    }
  }
});
```

### 9. 如何在 Webpack 中配置代码分割？

**方法：**

**1. 入口配置：**
```javascript
module.exports = {
  entry: {
    app: './src/app.js',
    admin: './src/admin.js'
  }
};
```

**2. 动态导入：**
```javascript
import(/* webpackChunkName: "lodash" */ 'lodash').then((_) => {
  // 使用 lodash
});
```

**3. SplitChunksPlugin：**
```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

### 10. source map 是什么？有哪些类型？

**Source Map：**
源代码与构建后代码的映射关系，用于调试。

**常用类型：**

| 类型                         | 构建速度 | 重构建速度 | 生产环境 | 质量 |
| ---------------------------- | -------- | ---------- | -------- | ---- |
| eval                         | +++++    | +++++      | ❌        | 低   |
| cheap-eval-source-map        | +        | ++         | ❌        | 较低 |
| cheap-module-eval-source-map | o        | ++         | ❌        | 中   |
| eval-source-map              | --       | +          | ❌        | 高   |
| cheap-source-map             | +        | o          | ✅        | 较低 |
| cheap-module-source-map      | o        | -          | ✅        | 中   |
| source-map                   | --       | --         | ✅        | 高   |
| hidden-source-map            | --       | --         | ✅        | 高   |

**推荐：**
- 开发环境：`eval-cheap-module-source-map`
- 生产环境：`source-map` 或 `hidden-source-map`

### 11. 如何编写一个 Webpack Loader？

**基本结构：**
```javascript
// my-loader.js
module.exports = function(source) {
  // source 是原始内容
  // this 是 loader 的上下文
  
  // 处理内容
  const result = source.replace(/console\.log\(/g, 'console.info(');
  
  // 返回处理后的内容
  return result;
};
```

**异步 Loader：**
```javascript
module.exports = function(source) {
  const callback = this.async();
  
  someAsyncOperation(source, (err, result) => {
    if (err) return callback(err);
    callback(null, result);
  });
};
```

**使用：**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: path.resolve(__dirname, 'my-loader.js')
      }
    ]
  }
};
```

### 12. 如何编写一个 Webpack Plugin？

**基本结构：**
```javascript
class MyPlugin {
  apply(compiler) {
    // 监听编译完成事件
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('编译完成！');
    });
    
    // 监听生成资源到 output 目录之前
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // 添加一个文件
      compilation.assets['file.txt'] = {
        source: () => 'Hello World',
        size: () => 11
      };
      callback();
    });
  }
}

module.exports = MyPlugin;
```

**使用：**
```javascript
const MyPlugin = require('./my-plugin');

module.exports = {
  plugins: [
    new MyPlugin()
  ]
};
```

### 13. Webpack 的 chunk 是什么？

**Chunk：**
代码块，是 Webpack 打包过程中的一组模块。

**类型：**
1. **Entry Chunk**：入口 chunk，包含入口模块及其依赖
2. **Normal Chunk**：普通 chunk，通过代码分割产生
3. **Initial Chunk**：初始 chunk，会在页面加载时加载
4. **Non-Initial Chunk**：非初始 chunk，按需加载

**生成方式：**
- entry 配置
- 动态 import
- SplitChunksPlugin

### 14. Vite 如何处理 CSS？

**内置支持：**
```javascript
// 直接导入
import './style.css';

// CSS Modules
import styles from './style.module.css';

// 预处理器
import './style.scss';
import './style.less';
```

**PostCSS：**
```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
};
```

**配置：**
```javascript
export default defineConfig({
  css: {
    modules: {
      localsConvention: 'camelCase'
    },
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`
      }
    },
    postcss: {
      plugins: [
        require('autoprefixer')
      ]
    }
  }
});
```

### 15. 如何在生产环境中使用 Webpack？

**最佳实践：**

```javascript
// webpack.prod.js
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = merge(common, {
  mode: 'production',
  devtool: 'source-map',
  
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js',
    clean: true
  },
  
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true
          }
        }
      }),
      new CssMinimizerPlugin()
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        }
      }
    },
    runtimeChunk: 'single'
  },
  
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash:8].css'
    })
  ]
});
```

## 最佳实践

### 1. Webpack 最佳实践

**开发环境：**
- ✅ 使用 webpack-dev-server
- ✅ 启用 HMR
- ✅ 使用 eval-cheap-module-source-map
- ✅ 启用缓存

**生产环境：**
- ✅ 代码分割
- ✅ Tree Shaking
- ✅ 压缩代码
- ✅ 提取 CSS
- ✅ 使用 contenthash
- ✅ 开启 Scope Hoisting

**通用：**
- ✅ 合理配置 resolve
- ✅ 使用路径别名
- ✅ 配置 .gitignore
- ✅ 环境变量管理

### 2. Vite 最佳实践

**开发：**
- ✅ 使用原生 ESM
- ✅ 合理配置预构建
- ✅ 使用插件系统
- ✅ 配置路径别名

**生产：**
- ✅ 合理配置代码分割
- ✅ 优化资源处理
- ✅ 配置 CDN
- ✅ 开启压缩

**通用：**
- ✅ 使用 TypeScript
- ✅ 环境变量管理
- ✅ 使用 ESLint
- ✅ 配置 Git Hooks

### 3. 性能监控

**Webpack Bundle Analyzer：**
```javascript
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
};
```

**Speed Measure Plugin：**
```javascript
const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeasurePlugin();

module.exports = smp.wrap({
  // webpack 配置
});
```

## 总结

前端工程化是现代前端开发的基础，掌握 Webpack 和 Vite 需要：

**Webpack：**
1. 理解核心概念（Entry、Output、Loader、Plugin）
2. 掌握配置方法
3. 了解构建流程
4. 掌握优化技巧
5. 会编写 Loader 和 Plugin

**Vite：**
1. 理解工作原理
2. 掌握配置方法
3. 了解预构建
4. 掌握优化技巧
5. 使用插件生态

**通用技能：**
- 性能优化意识
- 问题排查能力
- 工程化思维
- 持续学习

持续学习，在实践中提升工程化能力！

