# 前端算法面试题

## 数据结构基础

### 1. 数组（Array）

**基本操作：**
```javascript
// 创建数组
const arr = [1, 2, 3, 4, 5];
const arr2 = new Array(5);
const arr3 = Array.of(1, 2, 3);
const arr4 = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']

// 增删改查
arr.push(6);        // 尾部添加
arr.pop();          // 尾部删除
arr.unshift(0);     // 头部添加
arr.shift();        // 头部删除
arr.splice(2, 1);   // 删除索引2的元素
arr[0] = 10;        // 修改

// 遍历
arr.forEach((item, index) => console.log(item));
arr.map(item => item * 2);
arr.filter(item => item > 3);
arr.reduce((acc, cur) => acc + cur, 0);

// 查找
arr.indexOf(3);
arr.includes(3);
arr.find(item => item > 3);
arr.findIndex(item => item > 3);
```

**常用方法时间复杂度：**

| 方法             | 时间复杂度 |
| ---------------- | ---------- |
| push/pop         | O(1)       |
| unshift/shift    | O(n)       |
| splice           | O(n)       |
| indexOf/includes | O(n)       |
| sort             | O(n log n) |

### 2. 链表（Linked List）

**单链表实现：**
```javascript
class ListNode {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  
  // 添加节点
  append(val) {
    const newNode = new ListNode(val);
    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }
    this.size++;
  }
  
  // 插入节点
  insert(val, index) {
    if (index < 0 || index > this.size) return false;
    
    const newNode = new ListNode(val);
    
    if (index === 0) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      let current = this.head;
      let prev = null;
      let i = 0;
      
      while (i < index) {
        prev = current;
        current = current.next;
        i++;
      }
      
      newNode.next = current;
      prev.next = newNode;
    }
    
    this.size++;
    return true;
  }
  
  // 删除节点
  remove(index) {
    if (index < 0 || index >= this.size) return null;
    
    let current = this.head;
    
    if (index === 0) {
      this.head = current.next;
    } else {
      let prev = null;
      let i = 0;
      
      while (i < index) {
        prev = current;
        current = current.next;
        i++;
      }
      
      prev.next = current.next;
    }
    
    this.size--;
    return current.val;
  }
  
  // 查找节点
  get(index) {
    if (index < 0 || index >= this.size) return null;
    
    let current = this.head;
    let i = 0;
    
    while (i < index) {
      current = current.next;
      i++;
    }
    
    return current.val;
  }
  
  // 反转链表
  reverse() {
    let prev = null;
    let current = this.head;
    
    while (current) {
      const next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }
    
    this.head = prev;
  }
}
```

### 3. 栈（Stack）

**栈实现：**
```javascript
class Stack {
  constructor() {
    this.items = [];
  }
  
  // 入栈
  push(element) {
    this.items.push(element);
  }
  
  // 出栈
  pop() {
    return this.items.pop();
  }
  
  // 查看栈顶
  peek() {
    return this.items[this.items.length - 1];
  }
  
  // 是否为空
  isEmpty() {
    return this.items.length === 0;
  }
  
  // 栈大小
  size() {
    return this.items.length;
  }
  
  // 清空栈
  clear() {
    this.items = [];
  }
}

// 应用：括号匹配
function isValid(s) {
  const stack = new Stack();
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };
  
  for (let char of s) {
    if (map[char]) {
      stack.push(char);
    } else {
      const top = stack.pop();
      if (map[top] !== char) {
        return false;
      }
    }
  }
  
  return stack.isEmpty();
}
```

### 4. 队列（Queue）

**队列实现：**
```javascript
class Queue {
  constructor() {
    this.items = [];
  }
  
  // 入队
  enqueue(element) {
    this.items.push(element);
  }
  
  // 出队
  dequeue() {
    return this.items.shift();
  }
  
  // 查看队首
  front() {
    return this.items[0];
  }
  
  // 是否为空
  isEmpty() {
    return this.items.length === 0;
  }
  
  // 队列大小
  size() {
    return this.items.length;
  }
}

// 循环队列
class CircularQueue {
  constructor(k) {
    this.queue = new Array(k);
    this.size = k;
    this.head = -1;
    this.tail = -1;
  }
  
  enQueue(value) {
    if (this.isFull()) return false;
    
    if (this.isEmpty()) {
      this.head = 0;
    }
    
    this.tail = (this.tail + 1) % this.size;
    this.queue[this.tail] = value;
    return true;
  }
  
  deQueue() {
    if (this.isEmpty()) return false;
    
    if (this.head === this.tail) {
      this.head = -1;
      this.tail = -1;
      return true;
    }
    
    this.head = (this.head + 1) % this.size;
    return true;
  }
  
  isEmpty() {
    return this.head === -1;
  }
  
  isFull() {
    return (this.tail + 1) % this.size === this.head;
  }
}
```

### 5. 树（Tree）

**二叉树节点：**
```javascript
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

// 二叉树遍历
class BinaryTree {
  // 前序遍历（根-左-右）
  preorderTraversal(root) {
    const result = [];
    
    const traverse = (node) => {
      if (!node) return;
      result.push(node.val);
      traverse(node.left);
      traverse(node.right);
    };
    
    traverse(root);
    return result;
  }
  
  // 中序遍历（左-根-右）
  inorderTraversal(root) {
    const result = [];
    
    const traverse = (node) => {
      if (!node) return;
      traverse(node.left);
      result.push(node.val);
      traverse(node.right);
    };
    
    traverse(root);
    return result;
  }
  
  // 后序遍历（左-右-根）
  postorderTraversal(root) {
    const result = [];
    
    const traverse = (node) => {
      if (!node) return;
      traverse(node.left);
      traverse(node.right);
      result.push(node.val);
    };
    
    traverse(root);
    return result;
  }
  
  // 层序遍历
  levelOrderTraversal(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length) {
      const level = [];
      const levelSize = queue.length;
      
      for (let i = 0; i < levelSize; i++) {
        const node = queue.shift();
        level.push(node.val);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      
      result.push(level);
    }
    
    return result;
  }
}
```

### 6. 哈希表（Hash Map）

**哈希表实现：**
```javascript
class HashMap {
  constructor(size = 100) {
    this.size = size;
    this.buckets = new Array(size);
  }
  
  // 哈希函数
  hash(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = (hash + key.charCodeAt(i)) % this.size;
    }
    return hash;
  }
  
  // 设置值
  set(key, value) {
    const index = this.hash(key);
    
    if (!this.buckets[index]) {
      this.buckets[index] = [];
    }
    
    // 查找是否已存在
    for (let i = 0; i < this.buckets[index].length; i++) {
      if (this.buckets[index][i][0] === key) {
        this.buckets[index][i][1] = value;
        return;
      }
    }
    
    // 不存在则添加
    this.buckets[index].push([key, value]);
  }
  
  // 获取值
  get(key) {
    const index = this.hash(key);
    
    if (!this.buckets[index]) return undefined;
    
    for (let i = 0; i < this.buckets[index].length; i++) {
      if (this.buckets[index][i][0] === key) {
        return this.buckets[index][i][1];
      }
    }
    
    return undefined;
  }
  
  // 删除
  delete(key) {
    const index = this.hash(key);
    
    if (!this.buckets[index]) return false;
    
    for (let i = 0; i < this.buckets[index].length; i++) {
      if (this.buckets[index][i][0] === key) {
        this.buckets[index].splice(i, 1);
        return true;
      }
    }
    
    return false;
  }
}
```

## 排序算法

### 1. 冒泡排序

```javascript
function bubbleSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    let swapped = false;
    
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    
    // 如果没有交换，说明已经有序
    if (!swapped) break;
  }
  
  return arr;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
// 稳定性：稳定
```

### 2. 选择排序

```javascript
function selectionSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i;
    
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  
  return arr;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
// 稳定性：不稳定
```

### 3. 插入排序

```javascript
function insertionSort(arr) {
  const n = arr.length;
  
  for (let i = 1; i < n; i++) {
    const key = arr[i];
    let j = i - 1;
    
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    
    arr[j + 1] = key;
  }
  
  return arr;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
// 稳定性：稳定
```

### 4. 快速排序

```javascript
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }
  
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left - 1;
  
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

// 时间复杂度：平均 O(n log n)，最坏 O(n²)
// 空间复杂度：O(log n)
// 稳定性：不稳定
```

### 5. 归并排序

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// 时间复杂度：O(n log n)
// 空间复杂度：O(n)
// 稳定性：稳定
```

### 6. 堆排序

```javascript
function heapSort(arr) {
  const n = arr.length;
  
  // 建立大顶堆
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  
  // 排序
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }
  
  return arr;
}

function heapify(arr, n, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;
  
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }
  
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }
  
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}

// 时间复杂度：O(n log n)
// 空间复杂度：O(1)
// 稳定性：不稳定
```

### 排序算法对比

| 算法     | 时间复杂度（最好） | 时间复杂度（平均） | 时间复杂度（最坏） | 空间复杂度 | 稳定性 |
| -------- | ------------------ | ------------------ | ------------------ | ---------- | ------ |
| 冒泡排序 | O(n)               | O(n²)              | O(n²)              | O(1)       | 稳定   |
| 选择排序 | O(n²)              | O(n²)              | O(n²)              | O(1)       | 不稳定 |
| 插入排序 | O(n)               | O(n²)              | O(n²)              | O(1)       | 稳定   |
| 快速排序 | O(n log n)         | O(n log n)         | O(n²)              | O(log n)   | 不稳定 |
| 归并排序 | O(n log n)         | O(n log n)         | O(n log n)         | O(n)       | 稳定   |
| 堆排序   | O(n log n)         | O(n log n)         | O(n log n)         | O(1)       | 不稳定 |

## 搜索算法

### 1. 线性搜索

```javascript
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
}

// 时间复杂度：O(n)
```

### 2. 二分搜索

```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

// 时间复杂度：O(log n)
// 前提：数组必须有序
```

## 常见算法技巧

### 1. 双指针

**两数之和（有序数组）：**
```javascript
function twoSum(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  
  while (left < right) {
    const sum = nums[left] + nums[right];
    
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return [];
}
```

**反转字符串：**
```javascript
function reverseString(s) {
  let left = 0;
  let right = s.length - 1;
  
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]];
    left++;
    right--;
  }
  
  return s;
}
```

**移除重复项：**
```javascript
function removeDuplicates(nums) {
  if (nums.length === 0) return 0;
  
  let slow = 0;
  
  for (let fast = 1; fast < nums.length; fast++) {
    if (nums[fast] !== nums[slow]) {
      slow++;
      nums[slow] = nums[fast];
    }
  }
  
  return slow + 1;
}
```

### 2. 滑动窗口

**最长不重复子串：**
```javascript
function lengthOfLongestSubstring(s) {
  const map = new Map();
  let maxLen = 0;
  let left = 0;
  
  for (let right = 0; right < s.length; right++) {
    if (map.has(s[right])) {
      left = Math.max(left, map.get(s[right]) + 1);
    }
    
    map.set(s[right], right);
    maxLen = Math.max(maxLen, right - left + 1);
  }
  
  return maxLen;
}
```

**最小覆盖子串：**
```javascript
function minWindow(s, t) {
  const need = new Map();
  const window = new Map();
  
  for (let char of t) {
    need.set(char, (need.get(char) || 0) + 1);
  }
  
  let left = 0, right = 0;
  let valid = 0;
  let start = 0, len = Infinity;
  
  while (right < s.length) {
    const c = s[right];
    right++;
    
    if (need.has(c)) {
      window.set(c, (window.get(c) || 0) + 1);
      if (window.get(c) === need.get(c)) {
        valid++;
      }
    }
    
    while (valid === need.size) {
      if (right - left < len) {
        start = left;
        len = right - left;
      }
      
      const d = s[left];
      left++;
      
      if (need.has(d)) {
        if (window.get(d) === need.get(d)) {
          valid--;
        }
        window.set(d, window.get(d) - 1);
      }
    }
  }
  
  return len === Infinity ? '' : s.substr(start, len);
}
```

### 3. 动态规划

**斐波那契数列：**
```javascript
// 递归（效率低）
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// 动态规划
function fib(n) {
  if (n <= 1) return n;
  
  const dp = [0, 1];
  
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  
  return dp[n];
}

// 空间优化
function fib(n) {
  if (n <= 1) return n;
  
  let prev = 0, curr = 1;
  
  for (let i = 2; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  
  return curr;
}
```

**爬楼梯：**
```javascript
function climbStairs(n) {
  if (n <= 2) return n;
  
  let prev = 1, curr = 2;
  
  for (let i = 3; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  
  return curr;
}
```

**最长公共子序列：**
```javascript
function longestCommonSubsequence(text1, text2) {
  const m = text1.length;
  const n = text2.length;
  const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  
  return dp[m][n];
}
```

**背包问题：**
```javascript
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill(0).map(() => Array(capacity + 1).fill(0));
  
  for (let i = 1; i <= n; i++) {
    for (let w = 0; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          dp[i - 1][w],
          dp[i - 1][w - weights[i - 1]] + values[i - 1]
        );
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }
  
  return dp[n][capacity];
}
```

### 4. 回溯算法

**全排列：**
```javascript
function permute(nums) {
  const result = [];
  const used = new Array(nums.length).fill(false);
  
  function backtrack(path) {
    if (path.length === nums.length) {
      result.push([...path]);
      return;
    }
    
    for (let i = 0; i < nums.length; i++) {
      if (used[i]) continue;
      
      path.push(nums[i]);
      used[i] = true;
      backtrack(path);
      path.pop();
      used[i] = false;
    }
  }
  
  backtrack([]);
  return result;
}
```

**组合总和：**
```javascript
function combinationSum(candidates, target) {
  const result = [];
  
  function backtrack(start, path, sum) {
    if (sum === target) {
      result.push([...path]);
      return;
    }
    
    if (sum > target) return;
    
    for (let i = start; i < candidates.length; i++) {
      path.push(candidates[i]);
      backtrack(i, path, sum + candidates[i]);
      path.pop();
    }
  }
  
  backtrack(0, [], 0);
  return result;
}
```

**N皇后：**
```javascript
function solveNQueens(n) {
  const result = [];
  const board = Array(n).fill(0).map(() => Array(n).fill('.'));
  
  function isValid(row, col) {
    // 检查列
    for (let i = 0; i < row; i++) {
      if (board[i][col] === 'Q') return false;
    }
    
    // 检查左上对角线
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (board[i][j] === 'Q') return false;
    }
    
    // 检查右上对角线
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (board[i][j] === 'Q') return false;
    }
    
    return true;
  }
  
  function backtrack(row) {
    if (row === n) {
      result.push(board.map(row => row.join('')));
      return;
    }
    
    for (let col = 0; col < n; col++) {
      if (!isValid(row, col)) continue;
      
      board[row][col] = 'Q';
      backtrack(row + 1);
      board[row][col] = '.';
    }
  }
  
  backtrack(0);
  return result;
}
```

### 5. 贪心算法

**买卖股票的最佳时机：**
```javascript
function maxProfit(prices) {
  let minPrice = Infinity;
  let maxProfit = 0;
  
  for (let price of prices) {
    minPrice = Math.min(minPrice, price);
    maxProfit = Math.max(maxProfit, price - minPrice);
  }
  
  return maxProfit;
}
```

**跳跃游戏：**
```javascript
function canJump(nums) {
  let maxReach = 0;
  
  for (let i = 0; i < nums.length; i++) {
    if (i > maxReach) return false;
    maxReach = Math.max(maxReach, i + nums[i]);
  }
  
  return true;
}
```

## 前端特定算法

### 1. 防抖（Debounce）

```javascript
function debounce(fn, delay) {
  let timer = null;
  
  return function(...args) {
    if (timer) clearTimeout(timer);
    
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const handleInput = debounce((e) => {
  console.log('搜索:', e.target.value);
}, 500);
```

### 2. 节流（Throttle）

```javascript
function throttle(fn, delay) {
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用定时器实现
function throttle(fn, delay) {
  let timer = null;
  
  return function(...args) {
    if (timer) return;
    
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = null;
    }, delay);
  };
}
```

### 3. 深拷贝

```javascript
function deepClone(obj, map = new WeakMap()) {
  // 处理 null 和基本类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理正则
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理循环引用
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    const clone = [];
    map.set(obj, clone);
    for (let i = 0; i < obj.length; i++) {
      clone[i] = deepClone(obj[i], map);
    }
    return clone;
  }
  
  // 处理对象
  const clone = {};
  map.set(obj, clone);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  
  return clone;
}
```

### 4. 扁平化数组

```javascript
// 方法一：递归
function flatten(arr) {
  const result = [];
  
  for (let item of arr) {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  }
  
  return result;
}

// 方法二：reduce
function flatten(arr) {
  return arr.reduce((acc, cur) => {
    return acc.concat(Array.isArray(cur) ? flatten(cur) : cur);
  }, []);
}

// 方法三：flat（ES2019）
const arr = [1, [2, [3, [4]]]];
arr.flat(Infinity); // [1, 2, 3, 4]
```

### 5. 数组去重

```javascript
// 方法一：Set
function unique(arr) {
  return [...new Set(arr)];
}

// 方法二：filter + indexOf
function unique(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

// 方法三：reduce
function unique(arr) {
  return arr.reduce((acc, cur) => {
    return acc.includes(cur) ? acc : [...acc, cur];
  }, []);
}

// 方法四：Map
function unique(arr) {
  const map = new Map();
  return arr.filter(item => !map.has(item) && map.set(item, true));
}
```

### 6. 函数柯里化

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

// 使用
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

### 7. 发布订阅模式

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  // 订阅
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  // 发布
  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(callback => {
        callback(...args);
      });
    }
  }
  
  // 取消订阅
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
  
  // 只订阅一次
  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }
}
```

### 8. Promise 实现

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };
    
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };
    
    const promise2 = new MyPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        });
      }
      
      if (this.state === 'rejected') {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        });
      }
      
      if (this.state === 'pending') {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          });
        });
        
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          });
        });
      }
    });
    
    return promise2;
  }
  
  catch(onRejected) {
    return this.then(null, onRejected);
  }
}
```

### 9. 虚拟 DOM Diff 算法

```javascript
// 简化版 Diff 算法
function diff(oldVNode, newVNode) {
  // 节点类型不同，直接替换
  if (oldVNode.type !== newVNode.type) {
    return { type: 'REPLACE', newVNode };
  }
  
  // 文本节点
  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {
    if (oldVNode !== newVNode) {
      return { type: 'TEXT', newVNode };
    }
    return null;
  }
  
  // 比较属性
  const propsPatches = diffProps(oldVNode.props, newVNode.props);
  
  // 比较子节点
  const childrenPatches = diffChildren(oldVNode.children, newVNode.children);
  
  if (propsPatches || childrenPatches) {
    return {
      type: 'UPDATE',
      propsPatches,
      childrenPatches
    };
  }
  
  return null;
}

function diffProps(oldProps, newProps) {
  const patches = {};
  
  // 检查修改和新增
  for (let key in newProps) {
    if (oldProps[key] !== newProps[key]) {
      patches[key] = newProps[key];
    }
  }
  
  // 检查删除
  for (let key in oldProps) {
    if (!(key in newProps)) {
      patches[key] = undefined;
    }
  }
  
  return Object.keys(patches).length > 0 ? patches : null;
}

function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const maxLen = Math.max(oldChildren.length, newChildren.length);
  
  for (let i = 0; i < maxLen; i++) {
    patches.push(diff(oldChildren[i], newChildren[i]));
  }
  
  return patches;
}
```

### 10. LRU 缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }
    
    // 移到最后（最近使用）
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  put(key, value) {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    
    // 添加到最后
    this.cache.set(key, value);
    
    // 超出容量，删除最久未使用的（第一个）
    if (this.cache.size > this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
}
```

## 常见面试题

### 1. 两数之和

```javascript
// 方法一：暴力解法
function twoSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return [];
}

// 方法二：哈希表
function twoSum(nums, target) {
  const map = new Map();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  
  return [];
}
```

### 2. 反转链表

```javascript
function reverseList(head) {
  let prev = null;
  let current = head;
  
  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }
  
  return prev;
}

// 递归版本
function reverseList(head) {
  if (!head || !head.next) return head;
  
  const newHead = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
```

### 3. 有效的括号

```javascript
function isValid(s) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };
  
  for (let char of s) {
    if (map[char]) {
      stack.push(char);
    } else {
      const top = stack.pop();
      if (map[top] !== char) {
        return false;
      }
    }
  }
  
  return stack.length === 0;
}
```

### 4. 二叉树的最大深度

```javascript
function maxDepth(root) {
  if (!root) return 0;
  
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

### 5. 买卖股票的最佳时机

```javascript
function maxProfit(prices) {
  let minPrice = Infinity;
  let maxProfit = 0;
  
  for (let price of prices) {
    minPrice = Math.min(minPrice, price);
    maxProfit = Math.max(maxProfit, price - minPrice);
  }
  
  return maxProfit;
}
```

### 6. 无重复字符的最长子串

```javascript
function lengthOfLongestSubstring(s) {
  const map = new Map();
  let maxLen = 0;
  let left = 0;
  
  for (let right = 0; right < s.length; right++) {
    if (map.has(s[right])) {
      left = Math.max(left, map.get(s[right]) + 1);
    }
    
    map.set(s[right], right);
    maxLen = Math.max(maxLen, right - left + 1);
  }
  
  return maxLen;
}
```

### 7. 合并两个有序数组

```javascript
function merge(nums1, m, nums2, n) {
  let i = m - 1;
  let j = n - 1;
  let k = m + n - 1;
  
  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) {
      nums1[k--] = nums1[i--];
    } else {
      nums1[k--] = nums2[j--];
    }
  }
  
  while (j >= 0) {
    nums1[k--] = nums2[j--];
  }
}
```

### 8. 爬楼梯

```javascript
function climbStairs(n) {
  if (n <= 2) return n;
  
  let prev = 1, curr = 2;
  
  for (let i = 3; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  
  return curr;
}
```

### 9. 最长公共前缀

```javascript
function longestCommonPrefix(strs) {
  if (strs.length === 0) return '';
  
  let prefix = strs[0];
  
  for (let i = 1; i < strs.length; i++) {
    while (strs[i].indexOf(prefix) !== 0) {
      prefix = prefix.substring(0, prefix.length - 1);
      if (prefix === '') return '';
    }
  }
  
  return prefix;
}
```

### 10. 三数之和

```javascript
function threeSum(nums) {
  const result = [];
  nums.sort((a, b) => a - b);
  
  for (let i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      
      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        
        while (left < right && nums[left] === nums[left + 1]) left++;
        while (left < right && nums[right] === nums[right - 1]) right--;
        
        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }
  
  return result;
}
```

## 算法刷题建议

### 1. 学习路线

**第一阶段：基础（1-2周）**
- 数组、字符串
- 链表
- 栈和队列
- 哈希表

**第二阶段：进阶（2-3周）**
- 树（二叉树、二叉搜索树）
- 排序算法
- 搜索算法
- 双指针、滑动窗口

**第三阶段：提高（3-4周）**
- 动态规划
- 回溯算法
- 贪心算法
- 图算法

### 2. 刷题平台

- LeetCode（力扣）
- 牛客网
- 剑指 Offer
- CodeWars
- HackerRank

### 3. 刷题策略

**按专题刷：**
1. 先学习理论知识
2. 做同类型题目
3. 总结模板和技巧
4. 定期复习

**由易到难：**
1. Easy → Medium → Hard
2. 不要死磕难题
3. 多做中等难度题

**重复刷题：**
1. 第一遍：理解题意，看题解
2. 第二遍：自己实现
3. 第三遍：优化代码
4. 定期回顾

### 4. 面试准备

**常考题型：**
- 数组和字符串（30%）
- 链表（15%）
- 树（20%）
- 动态规划（15%）
- 排序和搜索（10%）
- 其他（10%）

**重点题目：**
- 两数之和
- 反转链表
- 有效的括号
- 二叉树遍历
- 最长公共子序列
- 买卖股票
- 爬楼梯
- 全排列

## 最佳实践

### 1. 代码质量

- ✅ 变量命名清晰
- ✅ 添加注释
- ✅ 考虑边界情况
- ✅ 时间空间复杂度分析
- ✅ 代码简洁优雅

### 2. 解题思路

1. 理解题意
2. 分析示例
3. 思考解法
4. 编写代码
5. 测试验证
6. 优化改进

### 3. 常见优化

- 使用哈希表优化查找
- 双指针优化遍历
- 动态规划优化递归
- 空间换时间
- 剪枝优化

## 总结

前端算法是面试的重要部分，掌握算法需要：

1. **扎实的基础**：数据结构、基础算法
2. **常见技巧**：双指针、滑动窗口、动态规划
3. **大量练习**：刷题是王道
4. **总结归纳**：整理模板和套路
5. **持续学习**：不断提高

算法能力的提升需要时间和练习，保持耐心，持续刷题！

